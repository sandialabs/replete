package replete.ui.csv;

import java.util.ArrayList;
import java.util.List;

public abstract class CsvExporter {
    public static List<String> getColumnHeaders(List<AbstractCommonCsvColumn> columns) {
        List<String> items = new ArrayList<>();
        for(AbstractCommonCsvColumn column : columns) {
            items.add(column.getName());
        }
        return items;
    }

    /**
     * Create a list of CSV rows (i.e. a List of Lists of Strings).  The number of rows generated by a single
     * call to this method is determined by the number of "group" columns passed in the columns parameter.
     * See writeColumnsRecursive() for more information on group columns.
     *
     * @param obj The source object to perform column calculations on.
     * @param columns The list of columns that make up the CSV.
     * @return The resultant List of CSV report rows.
     */
    public static List<List<String>> writeColumnList(Object obj, List<AbstractCommonCsvColumn> columns) throws Exception {
        List<List<String>> listOfItems = new ArrayList<>();
        List<Object> items = new ArrayList<>();

        for(AbstractCommonCsvColumn column : columns) {
            Object data = column.getCellData(obj);
            if(data instanceof String) {
                String sData = (String) data;
                if(sData.isEmpty() && column.isImportantColumn()) {
                    return new ArrayList<>();
                }
            }
            items.add(data);
        }
        // At the end, we call the recursive version of this method, in case of group columns.
        // In the base case, writeColumnsRecursive will return immediately with
        // a List that contains a single List of Strings (that is, a List that contains one CSV row).
        return writeColumnsRecursive(listOfItems, items);
    }

    /**
     * This method recursively creates CSV rows based on the number of group columns present.  Sometimes, we
     * need CSV reports that simulate a map (i.e. several rows whose data remain fixed, except for one column
     * that changes to represent a group of information).  To achieve this, we recursively iterate through the
     * list of group column data, writing a row for each item in the group column data list as we go.  This
     * method also works for multiple group columns specified, although the number of resultant rows will
     * increase exponentially, and the CSV report would theoretically become unreadable at a certain point.
     *
     * @param listSoFar The list of finalized CSV rows written so far, passed down to subsequent recursive calls.
     * @param rowData The list of items to write in a single row.  If a list is detected inside this list,
     *                recursion is invoked to properly cover the list.
     * @return All CSV rows written so far.
     */
    private static List<List<String>> writeColumnsRecursive(List<List<String>> listSoFar, List<Object> rowData) {
        boolean nonStringItemFound = false;
        List<Object> itemsReplacement = new ArrayList<>();

        // First, check for non-String items in our rowData List, and note if they exist.
        for(int i = 0; i < rowData.size(); i++) {
            Object data = rowData.get(i);
            if(!(data instanceof String) && data != null) {
                nonStringItemFound = true;
                break;
            }
        }
        if(nonStringItemFound) {
            for(Object data : rowData) {
                if(data instanceof List<?>) {
                    if(isListOfStrings(data)) {
                        // If we found a List in rowData, it was not empty, and its type was String,
                        // then loop through all the Strings in that List.  For each String,
                        // take the CSV row as it exists so far (i.e. the itemsReplacement List),
                        // put the current String item in the appropriate spot, and recurse until
                        // there are no more Lists of Strings to do this to.
                        List<String> listStrings = (List<String>) data;
                        for(String listString : listStrings) {
                            itemsReplacement.clear();
                            itemsReplacement.addAll(rowData);
                            itemsReplacement.remove(rowData.indexOf(data));
                            itemsReplacement.add(rowData.indexOf(data), listString);
                            writeColumnsRecursive(listSoFar, itemsReplacement);
                        }
                    }
                    // Break out of the for-loop (we only need to handle the first time a List
                    // appears in rowData - the recursion will take care of the rest).
                    break;
                }
            }
        }

        // Verify that rowData only contains Strings (this will only happen in the base case).
        // If so, add it to listSoFar (our list of CSV rows).
        List<String> stringRowData = new ArrayList<>();
        nonStringItemFound = false;
        for(Object data : rowData) {
            if(data == null) {
                stringRowData.add(""); //Suppress null data to blank string
            } else if(!(data instanceof String)) {
                if(isListOfStrings(data)) {
                    nonStringItemFound = true;
                } else {
                    stringRowData.add("");
                }
            } else {
                stringRowData.add((String)data);
            }
        }
        if(!nonStringItemFound) {
            listSoFar.add(stringRowData);
        }

        return listSoFar;
    }

    private static boolean isListOfStrings(Object data) {
        return data instanceof List<?> && !((List<?>) data).isEmpty() && ((List<?>) data).get(0) instanceof String;
    }

    public abstract boolean export(CsvModel csv) throws Exception;

    public abstract String getSuccessMessage();
}
