package replete.equality;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import replete.errors.RuntimeConvertedException;
import replete.util.ReflectionUtil;

// This class can perform a "deep" equality test on
// any two Java objects.  The equality is based only
// on the exactly equal nature of the primitives and
// Strings in the objects, not on any memory location
// or hash code information.

// This class DOES NOT use the result of the 'equals'
// method for anything other than simple types.  In
// other words, it will not respect your overridden
// equals methods.  This could be a future toggle-able
// feature if so needed.

// Note that the very nature of this algorithm could
// be subject to performance concerns, especially when
// comparing Set equality due to the semantics of what
// it means for two sets to be equal.

// Note that the comparison of Map objects does not
// have a defined behavior.

// For better autogenerated Eclipse hashCode/equals methods one day:
//   https://stackoverflow.com/questions/17782032/how-to-teach-eclipse-to-generate-compact-equals-and-hashcode-from-the-jdk-7
//   https://bugs.eclipse.org/bugs/show_bug.cgi?id=424214

/**
 * @author Derek Trumbo
 */

public class EqualityTester {


    ////////////////////////
    // INEQUALITY MESSAGE //
    ////////////////////////

    // A message that will be set by the equals method when
    // it returns false.
    private static String lastInequalityMessage;
    public static String getLastInequalityMessage() {
        return lastInequalityMessage;
    }

    // Used internally by the equalsRecursive method.
    private static void setInequalityMessage(String reason) {
        lastInequalityMessage = reason;
    }


    ///////////////////
    // PUBLIC METHOD //
    ///////////////////

    public static boolean equals(Object o1, Object o2) {

        // Initialize the inequality message to null at this
        // point.  If the equalsRecursive method returns true
        // this this message will remain null.  If the method
        // returns false, then the method will set this message
        // to a string indicating the reason of inequality.
        lastInequalityMessage = null;

        TestedPairs pairs = new TestedPairs();

        return equalsRecursive(o1, o2, pairs);
    }


    /////////////////////
    // PRIVATE METHODS //
    /////////////////////

    private static boolean equalsRecursive(Object o1, Object o2, TestedPairs pairs) {

        // Step 1: Null checks
        if(o1 == null && o2 == null) {
            return true;
        }
        if(o1 == null && o2 != null || o1 != null && o2 == null) {
            setInequalityMessage("one object is null and the other isn't");
            return false;
        }
        // !==> o1 and o2 are both not null at this point.


        // Step 2: Identity check.  Using the == operator, immediately
        // return true if the two object references point to the same
        // object.
        if(o1 == o2) {
            return true;
        }
        // !==> o1 and o2 are not the same object at this point.


        // Step 3: Class check.  Make sure the two objects are the same
        // type of object.
        Class<?> c1 = o1.getClass();
        Class<?> c2 = o2.getClass();
        if(!c1.equals(c2)) {
            setInequalityMessage("one object is of type '" + c1.getSimpleName() +
                "' and the other is of type '" + c2.getSimpleName() + "'");
            return false;
        }
        // !==> Both objects' classes are the same at this point.


        // Step 4: Make sure that these two objects have not
        // been tested at an earlier level (stack frame).  If they
        // have, then just return true indicating that they are
        // "equal" so that it does not affect the overall comparison.
        // Without this the potential for infinite recursion exists.
        if(pairs.existsPair(o1, o2)) {
            return true;
        }
        pairs.rememberPair(o1, o2);
        // !==> This pair of objects have not been tested before.


        // Step 5: Determine equality for simple types (the 8
        // primitive types and Strings).
        if(isSimpleType(c1)) {
            return equalSimpleValues(o1, o2, pairs);
        }
        // !==> The objects are not of a simple type at this point.


        // Step 6: Determine equality for arrays.  We must compare
        // array objects in a special manner, as they do not have fields
        // that can be reflected upon.
        if(isArray(c1)) {
            return equalArrays(o1, o2, pairs);
        }
        // !==> The objects are not arrays at this point.


        // Step 7: Determine equality for List types.  We don't want
        // to simply inspect the object's internal fields due to the
        // expected complexity therein, but rather desire to utilize
        // the public API to determine equality.
        if(isList(c1)) {
            return equalLists(o1, o2, pairs);
        }
        // !==> The objects are not List's at this point.


        // Step 8: Determine equality for Set types.  We don't want
        // to simply inspect the object's internal fields due to the
        // expected complexity therein, but rather desire to utilize
        // the public API to determine equality.
        // *NOTE: The performance of this procedure is exceedingly poor
        // An O(n^2) algorithm is the only one which can determine
        // equality under the semantics of the EqualityTester class.
        if(isSet(c1)) {
            return equalSets(o1, o2, pairs);
        }
        // !==> The objects are not Set's at this point.

        if(isMap(c1)) {
            return equalMaps(o1, o2, pairs);
        }

        // *NOTE: Map's are not supported yet.  The behavior of comparing
        // two Map objects is undefined.


        // Step 9: Now that the special types have been checked, just
        // compare the two objects as generically as possible, by
        // comparing the corresponding fields in both objects.
        return equalObjects(o1, o2, pairs);
    }

    /// TYPE-CHECKING METHODS ///

    // Returns whether or not a given Class object is a simple type.
    // Class.isPrimitive does not include wrapper classes nor the
    // String class.
    private static boolean isSimpleType(Class<?> type) {
        return type.equals(boolean.class) || type.equals(Boolean.class) ||
               type.equals(byte.class) || type.equals(Byte.class) ||
               type.equals(char.class) || type.equals(Character.class) ||
               type.equals(short.class) || type.equals(Short.class) ||
               type.equals(int.class) || type.equals(Integer.class) ||
               type.equals(float.class) || type.equals(Float.class) ||
               type.equals(long.class) || type.equals(Long.class) ||
               type.equals(double.class) || type.equals(Double.class) ||
               type.equals(String.class);
    }

    // Returns whether or not a given Class object represents
    // character data.  This is just used to determine the
    // formatting of an inequality message.
    private static boolean isStringType(Class<?> type) {
        return type.equals(char.class) || type.equals(Character.class) ||
               type.equals(String.class);
    }

    // Returns whether or not a given Class object is an array.
    private static boolean isArray(Class<?> type) {
        return type.isArray();
    }

    // Returns whether or not a given Class object is a List (implements
    // the List interface).
    private static boolean isList(Class<?> type) {
        return List.class.isAssignableFrom(type);
    }

    // Returns whether or not a given Class object is a Set (implements
    // the Set interface).
    private static boolean isSet(Class<?> type) {
        return Set.class.isAssignableFrom(type);
    }

    private static boolean isMap(Class<?> type) {
        return Map.class.isAssignableFrom(type);
    }

    /// SPECIFIC EQUALITY METHODS ///

    private static boolean equalSimpleValues(Object o1, Object o2, TestedPairs pairs) {
        if(o1.equals(o2)) {
            return true;
        }
        String s1 = isStringType(o1.getClass()) ? ("'" + o1 + "'") : o1.toString();
        String s2 = isStringType(o2.getClass()) ? ("'" + o2 + "'") : o2.toString();
        setInequalityMessage("the simple type values unequal (" + s1 + " != " + s2 + ")");
        return false;
    }

    private static boolean equalArrays(Object o1, Object o2, TestedPairs pairs) {
        int len1 = Array.getLength(o1);
        int len2 = Array.getLength(o2);

        // Check the sizes of the arrays.
        if(len1 != len2) {
            setInequalityMessage("array sizes unequal (" + len1 + " != " + len2 + ")");
            return false;
        }
        // !==> Now the two arrays have same # of elements at
        //      this point.

        // Iterate over the elements and recursively call
        // the equals method to determine equality.
        for(int i = 0; i < len1; i++) {
            Object elem1 = Array.get(o1, i);
            Object elem2 = Array.get(o2, i);

            if(!EqualityTester.equalsRecursive(elem1, elem2, pairs)) {
                setInequalityMessage("array elements at (" + i + ") unequal; " + lastInequalityMessage);
                return false;
            }
        }
        // !==> All elements in the arrays are equal at this point.

        return true;
    }

    private static boolean equalLists(Object o1, Object o2, TestedPairs pairs) {
        List<?> list1 = (List<?>) o1;
        List<?> list2 = (List<?>) o2;

        // Check the sizes of the lists.
        if(list1.size() != list2.size()) {
            setInequalityMessage("list sizes unequal (" + list1.size() + " != " + list2.size() + ")");
            return false;
        }
        // !==> Now the two lists have same # of elements at
        //      this point.

        // Iterate over the elements and recursively call
        // the equals method to determine equality.
        for(int i = 0; i < list1.size(); i++) {
            Object elem1 = list1.get(i);
            Object elem2 = list2.get(i);

            if(!EqualityTester.equalsRecursive(elem1, elem2, pairs)) {
                setInequalityMessage("list elements at (" + i + ") unequal; " + lastInequalityMessage);
                return false;
            }
        }
        // !==> All elements in the lists are equal at this point.

        return true;
    }

    private static boolean equalSets(Object o1, Object o2, TestedPairs pairs) {
        Set<?> set1 = (Set<?>) o1;
        Set<?> set2 = (Set<?>) o2;

        // Check the sizes of the lists.
        if(set1.size() != set2.size()) {
            setInequalityMessage("set sizes unequal (" + set1.size() + " != " + set2.size() + ")");
            return false;
        }
        // !==> Now the two sets have same # of elements at
        //      this point.

        Object[] elems1 = set1.toArray();
        Object[] elems2 = set2.toArray();

        // *Extremely inefficient*, but necessary to fulfill semantics of the
        // EqualityTester class.
        for(Object elem1 : elems1) {
            boolean exists = false;
            for(Object elem2 : elems2) {
                if(EqualityTester.equalsRecursive(elem1, elem2, pairs)) {
                    exists = true;
                    break;
                }
            }
            if(!exists) {
                setInequalityMessage("first set contains element not in second set");
                return false;
            }
        }
        for(Object elem2 : elems2) {
            boolean exists = false;
            for(Object elem1 : elems1) {
                if(EqualityTester.equalsRecursive(elem1, elem2, pairs)) {
                    exists = true;
                    break;
                }
            }
            if(!exists) {
                setInequalityMessage("second set contains element not in first set");
                return false;
            }
        }
        // !==> All elements in the sets are equal at this point.

        return true;
    }

    private static boolean equalMaps(Object o1, Object o2, TestedPairs pairs) {
        Map<?, ?> map1 = (Map<?, ?>) o1;
        Map<?, ?> map2 = (Map<?, ?>) o2;

        // Check the sizes of the lists.
        if(map1.size() != map2.size()) {
            setInequalityMessage("map sizes unequal (" + map1.size() + " != " + map2.size() + ")");
            return false;
        }
        // !==> Now the two sets have same # of elements at
        //      this point.

        if(!map1.equals(map2)) {
            setInequalityMessage("maps unequal");
            return false;
        }

        // TODO: One day could add the detail that list and set have.

        return true;
    }

    private static boolean equalObjects(Object o1, Object o2, TestedPairs pairs) {
        Field[] fields = ReflectionUtil.getFields(o1);

        for(Field f : fields) {

            // If the field is private, make it accessible.
            f.setAccessible(true);

            // Get the two objects' values for this field.
            try {
                Object value1 = f.get(o1);
                Object value2 = f.get(o2);

                // Recursively determine whether the values are
                // equal with this very method.  If they are
                // not equal, then stop this method immediately
                // by returning false, otherwise let the loop
                // continue onto the next field.
                if(!equalsRecursive(value1, value2, pairs)) {
                    setInequalityMessage("field '" + f.getName() + "' unequal; " + lastInequalityMessage);
                    return false;
                }
                // !==> Both objects' values for this field are equal
                //      at this point.
            } catch(Exception e) {
                throw new RuntimeConvertedException(e);
            }

        }
        // !==> The values of all the objects' the fields are all
        //      equal at this point.

        return true;
    }


    //////////////////
    // PAIR HISTORY //
    //////////////////

    private static class TestedPairs {
        private Map<Object, Object> oneTwo = new HashMap<Object, Object>();
        private Map<Object, Object> twoOne = new HashMap<Object, Object>();

        public boolean existsPair(Object o1, Object o2) {
            return oneTwo.get(o1) == o2 || twoOne.get(o2) == o1;
        }
        public void rememberPair(Object o1, Object o2) {
            oneTwo.put(o1, o2);
            twoOne.put(o2, o1);
        }
    }


    //////////
    // TEST //
    //////////

    public static void main(String[] args) throws Exception {
        Cat cat1 = new Cat("fluffy", 93.F);
        Cat cat2 = new Cat("fluffy", 3.2F);
        cat1.owner = new CatOwner("tim");
        cat2.owner = new CatOwner("tim");
        cat1.owner.cat = cat2;
        cat2.owner.cat = cat2;
        System.out.println(equals(cat1, cat2));
        System.out.println(getLastInequalityMessage());
        if(true) {
            return;
        }


        Car c = new Car("Honda", "Civic", 1996);
        Car c2 = new Car("Honda", "Civic", 1996);
        Car c3 = new Car("Nissan", "Pathfinder", 2001);

        Owner o1 = new Owner("Derek", "Trumbo", 27);
        Owner o1b = new Owner("Derek", "Trumbo", 27);
        Owner o2 = new Owner("Ana", "Lopez", 25);

        ArrayX a1 = new ArrayX();
        ArrayX a2 = new ArrayX();
        a1.y = new HashSet();
        a2.y = new HashSet();
        a1.y.add("d");
        a2.y.add("dd");
        System.out.println(equals(a1, a2));
        System.out.println(getLastInequalityMessage());
        if(true) {
            return;
        }

        c.setOwner(o1);
        c2.setOwner(o1b);

        List l1 = new ArrayList();
        List l2 = new ArrayList();

        l1.add(new Wheel(20));
        l2.add(new Wheel(20));
        l1.add(new Wheel(25));
        l2.add("sdafd");
        //l2.add(new Wheel(20));

        c.setWheels(l1);
        c2.setWheels(l2);

        c3.setOwner(o2);

//        System.out.println(c.toString());
//        System.out.println(c.hashCode());
//        System.out.println(c2.toString());
//        System.out.println(c2.hashCode());

//        System.out.println(c.equals(c2));
//        System.out.println(c.equals(c3));
//        System.out.println(c2.equals(c3));

//        System.out.println(EqualityTester.equals(c, c2));
//        System.out.println(EqualityTester.equals(c, c3));
//        System.out.println(EqualityTester.equals(c2, c2));

        boolean e = equals(c, c2);//, "mycar", "yourcar"); //"wat", 34);//new Dog(), c2, "dog", "gwenyth");
        System.out.println("Equals? " + e);
        if(!e) {
            System.out.println("  Reason:\n      " + getLastInequalityMessage());
        }
    }


    /////////////////////////////////
    // PRIVATE CLASSES FOR TESTING //
    /////////////////////////////////

    private static class Cat {
        public float age;
        public CatOwner owner;
        public String name;
        public Cat(String name, float a) {
            this.name = name;
            age = a;
        }
    }

    private static class CatOwner {
        public String name;
        public Cat cat;
        public CatOwner(String name) {
            this.name = name;
        }
    }

    private static class ArrayX {
        public int[] x;
        public Set y;
    }
    private static class Dog {
        private boolean spayed;
        private String name;
    }
    private static class Car {
        private String make;
        private String model;
        private int year;
        public String insurance;

        private Owner owner;
        private List wheels= new ArrayList();

        public Car(String mk, String md, int yr) {
            make = mk;
            model = md;
            year = yr;
        }

        @Override
        public boolean equals(Object o) {

            //
            if(o == null) {
                return false;
            }
            if(!o.getClass().equals(Car.class)) {
                return false;
            }

            Car otherCar = (Car) o;

            if(!make.equals(otherCar.make)) {
                return false;
            }
            if(!model.equals(otherCar.model)) {
                return false;
            }
            if(year != otherCar.year) {
                return false;
            }

            return true;
        }

        @Override
        public String toString() {
            return make + " " + model + " " + year;
        }

        public String getMake() {
            return make;
        }

        public String getModel() {
            return model;
        }

        public int getYear() {
            return year;
        }

        public void setMake(String make) {
            this.make = make;
        }

        public void setModel(String model) {
            this.model = model;
        }

        public void setYear(int year) {
            this.year = year;
        }

        public Owner getOwner() {
            return owner;
        }

        public void setOwner(Owner owner) {
            this.owner = owner;
        }

        public List getWheels() {
            return wheels;
        }

        public void setWheels(List wheels) {
            this.wheels = wheels;
        }
    }
    private static class Owner {
        private String firstName;
        private String lastName;
        private int age;

        public Owner(String fn, String ln, int a) {
            firstName = fn;
            lastName = ln;
            age = a;
        }

        public String getFirstName() {
            return firstName;
        }

        public String getLastName() {
            return lastName;
        }

        public int getAge() {
            return age;
        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
    private static class Wheel {
        private float diameter;
        public Wheel(float d) {
            diameter = d;
        }
        public float getDiameter() {
            return diameter;
        }
        public void setDiameter(float diameter) {
            this.diameter = diameter;
        }
    }
}
