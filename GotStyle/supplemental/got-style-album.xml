<replete.xstream.SerializationResult>
  <metadata>
    <appName>&lt;unknown&gt;</appName>
    <serializationDate>2021-09-09 12:17:47 AM</serializationDate>
    <user>dtrumbo</user>
    <serializationLib>XStream</serializationLib>
    <serializationLibVersion>xstream-1.4.3/xpp3_min-1.1.4c</serializationLibVersion>
    <targetObjectClass>gotstyle.model.GotStyleModel</targetObjectClass>
  </metadata>
  <targetObject class="GotStyleModel">
    <examples>
      <Ex>
        <status>GOOD</status>
        <title>Foreword</title>
        <pages>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    [3rd TechTalk after Elliott&apos;s Unit Testing TechTalk.  JT to follow with Text Analytics]</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues

    * Reasons
      - Code Readability / Cleanliness
      - Self Documentation
      - Clarity of Purpose
      - Hidden Extensibility
      - Bug Prevention
      - Learn nuances about Java / Replete API
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues

    * Reasons
      - Code Readability / Cleanliness
      - Self Documentation
      - Clarity of Purpose
      - Hidden Extensibility
      - Bug Prevention
      - Learn nuances about Java / Replete API

    * Code Reviews Starting
      - Elliott has researched code review tools, one that integrates directly into TeamForge
      - This TechTalk will hopefully help convey my opinions on common programming pitfalls
        and reduce amount of back-and-forth during online code reviews.</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues

    * Reasons
      - Code Readability / Cleanliness
      - Self Documentation
      - Clarity of Purpose
      - Hidden Extensibility
      - Bug Prevention
      - Learn nuances about Java / Replete API

    * Code Reviews Starting
      - Elliott has researched code review tools, one that integrates directly into TeamForge
      - This TechTalk will hopefully help convey my opinions on common programming pitfalls
        and reduce amount of back-and-forth during online code reviews.

    * Actual Code! From 1462/3 Software Development Team Developers.  
      I wanted real world examples for an authentic talk.
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues

    * Reasons
      - Code Readability / Cleanliness
      - Self Documentation
      - Clarity of Purpose
      - Hidden Extensibility
      - Bug Prevention
      - Learn nuances about Java / Replete API

    * Code Reviews Starting
      - Elliott has researched code review tools, one that integrates directly into TeamForge
      - This TechTalk will hopefully help convey my opinions on common programming pitfalls
        and reduce amount of back-and-forth during online code reviews.

    * Actual Code! From 1462/3 Software Development Team Developers.  
      I wanted real world examples for an authentic talk.

    * Anonymous! It doesn&apos;t matter who original authors were.  
      We only are focusing on the code! Except for ... Mr. Anderson...
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues

    * Reasons
      - Code Readability / Cleanliness
      - Self Documentation
      - Clarity of Purpose
      - Hidden Extensibility
      - Bug Prevention
      - Learn nuances about Java / Replete API

    * Code Reviews Starting
      - Elliott has researched code review tools, one that integrates directly into TeamForge
      - This TechTalk will hopefully help convey my opinions on common programming pitfalls
        and reduce amount of back-and-forth during online code reviews.

    * Actual Code! From 1462/3 Software Development Team Developers.  
      I wanted real world examples for an authentic talk.

    * Anonymous! It doesn&apos;t matter who original authors were.  
      We only are focusing on the code! Except for ... Mr. Anderson...

    * BUT... If I have specifically talked to you about certain code before, 
      feel free to give your colleagues a chance to answer questions before chiming in.
    </src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues

    * Reasons
      - Code Readability / Cleanliness
      - Self Documentation
      - Clarity of Purpose
      - Hidden Extensibility
      - Bug Prevention
      - Learn nuances about Java / Replete API

    * Code Reviews Starting
      - Elliott has researched code review tools, one that integrates directly into TeamForge
      - This TechTalk will hopefully help convey my opinions on common programming pitfalls
        and reduce amount of back-and-forth during online code reviews.

    * Actual Code! From 1462/3 Software Development Team Developers.  
      I wanted real world examples for an authentic talk.

    * Anonymous! It doesn&apos;t matter who original authors were.  
      We only are focusing on the code! Except for ... Mr. Anderson...

    * BUT... If I have specifically talked to you about certain code before, 
      feel free to give your colleagues a chance to answer questions before chiming in.

    * FAST QUIZ FORMAT
      - Probably won&apos;t get to all examples in 2 hours
      - Can schedule follow in with group or individuals if you enjoy this
      - Discussions and questions are OK though!!
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Foreword</msg>
            <src>
    Got Style? TechTalk

    * What Covered
      - Class/method/variable naming conventions and best practices
      - Code organization
      - Bug hunt
      - Style (whitespace, indentation, etc.)
      - OO / UI design issues

    * Reasons
      - Code Readability / Cleanliness
      - Self Documentation
      - Clarity of Purpose
      - Hidden Extensibility
      - Bug Prevention
      - Learn nuances about Java / Replete API

    * Code Reviews Starting
      - Elliott has researched code review tools, one that integrates directly into TeamForge
      - This TechTalk will hopefully help convey my opinions on common programming pitfalls
        and reduce amount of back-and-forth during online code reviews.

    * Actual Code! From 1462/3 Software Development Team Developers.  
      I wanted real world examples for an authentic talk.

    * Anonymous! It doesn&apos;t matter who original authors were.  
      We only are focusing on the code! Except for ... Mr. Anderson...

    * BUT... If I have specifically talked to you about certain code before, 
      feel free to give your colleagues a chance to answer questions before chiming in.
    
    * FAST QUIZ FORMAT
      - Probably won&apos;t get to all examples in 2 hours
      - Can schedule follow in with group or individuals if you enjoy this
      - Discussions and questions are OK though!!

    * Derek&apos;s 51% Rule - How I can be so opinionated about &quot;subjective&quot; opinions :)
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>btnUp.setEnabled(enabled)</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Thoughts?</msg>
            <src>
    if(tblUrls.getSelectedRowCount() &gt; 0) {
        btnUp.setEnabled(true);
        btnDown.setEnabled(true);
    } else {
        btnUp.setEnabled(false);
        btnDown.setEnabled(false);
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Until...</msg>
            <src>
    if(tblUrls.getSelectedRowCount() &gt; 0) {
        btnUp.setEnabled(true);
        btnDown.setEnabled(true);
        btnSortA.setEnabled(true);
        btnSortB.setEnabled(true);
        btnSortC.setEnabled(true);
        btnSortD.setEnabled(true);
    } else {
        btnUp.setEnabled(false);          &lt;bc:red&gt;// Two lines per button!&lt;/bc&gt;
        btnDown.setEnabled(false);
        btnSortA.setEnabled(false);
        btnSortB.setEnabled(false);
        btnSortC.setEnabled(false);
        btnSortD.setEnabled(false);
    }</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Half The Lines</msg>
            <src>
    boolean enabled = tblUrls.getSelectedRowCount() &gt; 0;
    btnUp.setEnabled(enabled);
    btnDown.setEnabled(enabled);
    btnSortA.setEnabled(enabled);
    btnSortB.setEnabled(enabled);
    btnSortC.setEnabled(enabled);
    btnSortD.setEnabled(enabled);</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Paren Heaven</msg>
            <src>
    boolean enabled = &lt;bc:blue&gt;(&lt;/bc&gt;tblUrls.getSelectedRowCount() &gt; 0&lt;bc:blue&gt;)&lt;/bc&gt;;   &lt;bc:blue&gt;// Superfluous parentheses OK&lt;/bc&gt;
    btnUp.setEnabled(enabled);
    btnDown.setEnabled(enabled);
    btnSortA.setEnabled(enabled);
    btnSortB.setEnabled(enabled);
    btnSortC.setEnabled(enabled);
    btnSortD.setEnabled(enabled);</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>SwingConstants ifs</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Dependable If&apos;s</msg>
            <src>
    if(value.equalsIgnoreCase(&quot;left&quot;)) {
        if(cmp instanceof JLabel) {
            ((JLabel) cmp).setHorizontalAlignment(SwingConstants.LEFT);
        } else {
            ((JTextField) cmp).setHorizontalAlignment(SwingConstants.LEFT);
        }
    } else if(value.equalsIgnoreCase(&quot;center&quot;)) {
        if(cmp instanceof JLabel) {
            ((JLabel) cmp).setHorizontalAlignment(SwingConstants.CENTER);
        } else {
            ((JTextField) cmp).setHorizontalAlignment(SwingConstants.CENTER);
        }
    } else if(value.equalsIgnoreCase(&quot;right&quot;)) {
        if(cmp instanceof JLabel) {
            ((JLabel) cmp).setHorizontalAlignment(SwingConstants.RIGHT);
        } else {
            ((JTextField) cmp).setHorizontalAlignment(SwingConstants.RIGHT);
        }
    } else if(value.equalsIgnoreCase(&quot;leading&quot;)) {
        if(cmp instanceof JLabel) {
            ((JLabel) cmp).setHorizontalAlignment(SwingConstants.LEADING);
        } else {
            ((JTextField) cmp).setHorizontalAlignment(SwingConstants.LEADING);
        }
    } else if(value.equalsIgnoreCase(&quot;trailing&quot;)) {
        if(cmp instanceof JLabel) {
            ((JLabel) cmp).setHorizontalAlignment(SwingConstants.TRAILING);
        } else {
            ((JTextField) cmp).setHorizontalAlignment(SwingConstants.TRAILING);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Maptastic</msg>
            <src>
    Map&lt;String, Integer&gt; alignments = new HashMap&lt;&gt;();
    alignments.put(&quot;left&quot;,     SwingConstants.LEFT);
    alignments.put(&quot;center&quot;,   SwingConstants.CENTER);
    alignments.put(&quot;right&quot;,    SwingConstants.RIGHT);
    alignments.put(&quot;leading&quot;,  SwingConstants.LEADING);
    alignments.put(&quot;trailing&quot;, SwingConstants.TRAILING);

    int alignment = alignments.get(value.toLowerCase());

    if(cmp instanceof JLabel) {
        ((JLabel) cmp).setHorizontalAlignment(alignment);
    } else {
        ((JTextField) cmp).setHorizontalAlignment(alignment);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>A reflection possibility</msg>
            <src>
    Map&lt;String, Integer&gt; alignments = new HashMap&lt;&gt;();
    alignments.put(&quot;left&quot;,     SwingConstants.LEFT);
    alignments.put(&quot;center&quot;,   SwingConstants.CENTER);
    alignments.put(&quot;right&quot;,    SwingConstants.RIGHT);
    alignments.put(&quot;leading&quot;,  SwingConstants.LEADING);
    alignments.put(&quot;trailing&quot;, SwingConstants.TRAILING);

    int alignment = alignments.get(value.toLowerCase());

    // Handles any component that happens to have that method.
    &lt;bc:blue&gt;ReflectionUtil.invoke(cmp, &quot;setHorizontalTextPosition&quot;, alignment);&lt;/bc&gt;
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>path != &quot;NONE&quot;</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Quick One</msg>
            <src>
    private Image getImage(RComboBox&lt;String&gt; picker) {
        String path = picker.getSelected();
        Image retImage = null;
        if(path != &quot;NONE&quot;) {
            retImage = ImageLib.get(path).getImage();
        }
        return retImage;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Simpler!</msg>
            <src>
    private Image getImage(RComboBox&lt;String&gt; picker) {
        String path = picker.getSelected();
        if(path != &quot;NONE&quot;) {
            return ImageLib.get(path).getImage();
        }
        return null;
    }
 </src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Bad String Theory</msg>
            <src>
    private Image getImage(RComboBox&lt;String&gt; picker) {
        String path = picker.getSelected();
        if(&lt;c:red&gt;path != &quot;NONE&quot;&lt;/c&gt;) {
            return ImageLib.get(path).getImage();
        }
        return null;
    }
 </src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Phew...</msg>
            <src>
    private Image getImage(RComboBox&lt;String&gt; picker) {
        String path = picker.getSelected();
        if(!path.equals(&quot;NONE&quot;)) {
            return ImageLib.get(path).getImage();
        }
        return null;
    }
 </src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>?</msg>
            <src>
    private static final String NONE_PATH_VALUE = &quot;NONE&quot;;

    private Image getImage(RComboBox&lt;String&gt; picker) {
        String path = picker.getSelected();
        if(!path.equals(NONE_PATH_VALUE)) {
            return ImageLib.get(path).getImage();
        }
        return null;
    }
 </src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>CountryCode parsing</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Just Some Standard Code...</msg>
            <src>
    System.out.println(parts[0] + &quot;&gt;&gt;&quot; + line);
    CountryCode code = new CountryCode();
    code.setTld(parts[0]);
    line = reader.readLine();
    String iconUrl = &quot;http:&quot; + StringUtil.extractPart(line, &quot;src=\&quot;&quot;, &quot;\&quot;&quot;);
    code.setIconUrl(iconUrl);
    int a = line.indexOf(&quot;&lt;/a&gt;&quot;);
    int b = line.lastIndexOf(&apos;&gt;&apos;, a);
    code.setCountryName(line.substring(b + 1, a));
    codes.add(code);
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Similar code spread around</msg>
            <src>
    System.out.println(parts[0] + &quot;&gt;&gt;&quot; + line);
    &lt;bc:red&gt;CountryCode code = new CountryCode();&lt;/bc&gt;
    &lt;bc:red&gt;code.setTld(parts[0]);&lt;/bc&gt;
    line = reader.readLine();
    String iconUrl = &quot;http:&quot; + StringUtil.extractPart(line, &quot;src=\&quot;&quot;, &quot;\&quot;&quot;);
    &lt;bc:red&gt;code.setIconUrl(iconUrl);&lt;/bc&gt;
    int a = line.indexOf(&quot;&lt;/a&gt;&quot;);
    int b = line.lastIndexOf(&apos;&gt;&apos;, a);
    &lt;bc:red&gt;code.setCountryName(line.substring(b + 1, a));&lt;/bc&gt;
    &lt;bc:red&gt;codes.add(code);&lt;/bc&gt;
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Organized</msg>
            <src>
    System.out.println(parts[0] + &quot; --&gt; &quot; + line);
    line = reader.readLine();
    String iconUrl = &quot;http:&quot; + StringUtil.extractPart(line, &quot;src=\&quot;&quot;, &quot;\&quot;&quot;);
    int a = line.indexOf(&quot;&lt;/a&gt;&quot;);
    int b = line.lastIndexOf(&apos;&gt;&apos;, a);

    codes.add(new CountryCode()
        .setTld(parts[0])
        .setIconUrl(iconUrl)
        .setCountryName(line.substring(b + 1, a))
    );
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Even Better?</msg>
            <src>
    System.out.println(parts[0] + &quot; --&gt; &quot; + line);
    line = reader.readLine();
    String iconUrl = &quot;http:&quot; + StringUtil.extractPart(line, &quot;src=\&quot;&quot;, &quot;\&quot;&quot;);
    int a = line.indexOf(&quot;&lt;/a&gt;&quot;);
    int b = line.lastIndexOf(&apos;&gt;&apos;, a);

    codes.add(
        new CountryCode()
            .setTld(parts[0])
            .setIconUrl(iconUrl)
            .setCountryName(line.substring(b + 1, a))
    );
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Other Improvements?</msg>
            <src>
    System.out.println(parts[0] + &quot; --&gt; &quot; + line);
    line = reader.readLine();
    String iconUrl = &quot;http:&quot; + StringUtil.extractPart(line, &quot;src=\&quot;&quot;, &quot;\&quot;&quot;);
    int a = line.indexOf(&quot;&lt;/a&gt;&quot;);
    int b = line.lastIndexOf(&apos;&gt;&apos;, a);

    codes.add(
        new CountryCode()
            .setTld(parts[0])
            .setIconUrl(iconUrl)
            .setCountryName(line.substring(b + 1, a))     // Notice how computation takes place here
    );                                                    // far away from the referenced variables.
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Now it&apos;s really organized</msg>
            <src>
    System.out.println(parts[0] + &quot; --&gt; &quot; + line);
    line = reader.readLine();

    // Extract fields
    String &lt;bc:blue&gt;tld&lt;/bc&gt; = parts[0];
    String &lt;bc:blue&gt;iconUrl&lt;/bc&gt; = &quot;http:&quot; + StringUtil.extractPart(line, &quot;src=\&quot;&quot;, &quot;\&quot;&quot;);
    int a = line.indexOf(&quot;&lt;/a&gt;&quot;);
    int b = line.lastIndexOf(&apos;&gt;&apos;, a);
    String &lt;bc:blue&gt;countryName&lt;/bc&gt; = line.substring(b + 1, a);

    // Construct and add country code
    codes.add(
        new CountryCode()
            .setTld(&lt;bc:blue&gt;tld&lt;/bc&gt;)
            .setIconUrl(&lt;bc:blue&gt;iconUrl&lt;/bc&gt;)
            .setCountryName(&lt;bc:blue&gt;countryName&lt;/bc&gt;)
    );
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Quick if</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Any changes?</msg>
            <src>
    @Override
    public String getValidationMessage() {
        String msg = pnlHttpRqOptions.getValidationMessage();
        if(msg != null) {
            return msg;
        }
        return null;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Well that was obvious...</msg>
            <src>
    @Override
    public String getValidationMessage() {
        return pnlHttpRqOptions.getValidationMessage();
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>FrontierSummaryState</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Thoughts?</msg>
            <src>
    @Override
    public FrontierSummaryState createSummaryState() {
        FrontierSummaryState frontierState = new FrontierSummaryState();
        IntSummaryStats flSizes = job.getFrontierLoaderSizes();
        frontierState.setFrontierLoaderSizes(flSizes);
        return frontierState;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Sorcery!</msg>
            <src>    
    @Override
    public FrontierSummaryState createSummaryState() {
        &lt;bc:blue&gt;return new FrontierSummaryState()
            .setFrontierLoaderSizes(job.getFrontierLoaderSizes())
        ;&lt;/bc&gt;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HttpRequestOptions getOptions() {
        HttpRequestOptions requestOptions = new HttpRequestOptions();   // Leave all other fields default.

        requestOptions.setSaveContent(chkSaveContent.isSelected());
        requestOptions.setSaveResponseHeaders(chkSaveResponseHeaders.isSelected());
        requestOptions.setSaveRedirects(chkSaveRedirects.isSelected());
        requestOptions.setSaveRedirectResponseHeaders(chkSaveRedirectResponseHeaders.isSelected());
        requestOptions.setSaveSecurity(chkSaveSecurity.isSelected());
        requestOptions.setSaveRequest(chkSaveRequest.isSelected());
        requestOptions.setPreemptor(cboPreemptor.getSelected().preemptor);
        requestOptions.setMaxContentLength(txtMaxContentLength.getLong());
        requestOptions.setTimeout(txtTimeout.getInteger());

        return requestOptions;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HttpRequestOptions getOptions() {
        &lt;bc:blue&gt;return new HttpRequestOptions()
            .setSaveContent(chkSaveContent.isSelected())
            .setSaveResponseHeaders(chkSaveResponseHeaders.isSelected())
            .setSaveRedirects(chkSaveRedirects.isSelected())
            .setSaveRedirectResponseHeaders(chkSaveRedirectResponseHeaders.isSelected())
            .setSaveSecurity(chkSaveSecurity.isSelected())
            .setSaveRequest(chkSaveRequest.isSelected())
            .setPreemptor(cboPreemptor.getSelected().preemptor)
            .setMaxContentLength(txtMaxContentLength.getLong())
            .setTimeout(txtTimeout.getInteger())
        ;&lt;/bc&gt;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>paint ul graphics</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>How Could This Be Bad??</msg>
            <src>
    private void ul(Graphics g, int dy) {
        g.setColor(new Color(240, 240, 240));
        int x1 = 1, x2 = 8, y1 = dy + 1, y2 = dy + 8;
        g.fillPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Quick name change</msg>
            <src>
    private void &lt;bc:red&gt;ul&lt;/bc&gt;(Graphics g, int dy) {
        g.setColor(new Color(240, 240, 240));
        int x1 = 1, x2 = 8, y1 = dy + 1, y2 = dy + 8;
        g.fillPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Ok, now what?</msg>
            <src>
    private void &lt;bc:blue&gt;paintUlTriangle&lt;/bc&gt;(Graphics g, int dy) {
        g.setColor(new Color(240, 240, 240));
        int x1 = 1, x2 = 8, y1 = dy + 1, y2 = dy + 8;
        g.fillPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Single Line Laziness</msg>
            <src>
    private void paintUlTriangle(Graphics g, int dy) {
        g.setColor(new Color(240, 240, 240));
        &lt;bc:red&gt;int x1 = 1, x2 = 8, y1 = dy + 1, y2 = dy + 8;&lt;/bc&gt;
        &lt;bc:red&gt;// Bad for 4 reasons: 
        //  1. Deletion (Ctrl+D), 
        //  2. Reordering (Alt+Up/Down)
        //  3. Toggling Comments (Ctrl+E - //)
        //  4. Documentation&lt;/bc&gt;
        g.fillPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Better</msg>
            <src>
    private void paintUlTriangle(Graphics g, int dy) {
        g.setColor(new Color(240, 240, 240));
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;
        g.fillPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Graphics code scattered</msg>
            <src>
    private void paintUlTriangle(Graphics g, int dy) {
        &lt;bc:red&gt;g.setColor(new Color(240, 240, 240));&lt;/bc&gt;
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;
        &lt;bc:red&gt;g.fillPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);&lt;/bc&gt;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Organized, But...</msg>
            <src>
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;
        
        g.setColor(new Color(240, 240, 240));
        g.fillPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
        
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, new int[] {y1, y1, y2}, 3);
    }
    </src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Duplicate Code</msg>
            <src>
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;
        
        g.setColor(new Color(240, 240, 240));
        g.fillPolygon(&lt;bc:red&gt;new int[] {x1, x2, x1}&lt;/bc&gt;, new int[] {y1, y1, y2}, 3);
        
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(&lt;bc:red&gt;new int[] {x1, x2, x1}&lt;/bc&gt;, new int[] {y1, y1, y2}, 3);
    }
    </src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Duplicate Code x2</msg>
            <src>
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;
        
        g.setColor(new Color(240, 240, 240));
        g.fillPolygon(new int[] {x1, x2, x1}, &lt;bc:red&gt;new int[] {y1, y1, y2}&lt;/bc&gt;, 3);
        
        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(new int[] {x1, x2, x1}, &lt;bc:red&gt;new int[] {y1, y1, y2}&lt;/bc&gt;, 3);
    }
    </src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Nice! Done?</msg>
            <src>    
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;     // 8 because ....

        &lt;bc:blue&gt;int[] xPath = new int[] {x1, x2, x1};
        int[] yPath = new int[] {y1, y1, y2};&lt;/bc&gt;

        g.setColor(new Color(240, 240, 240));
        g.fillPolygon(xPath, yPath, 3);

        g.setColor(new Color(220, 220, 220));
        g.drawPolygon(xPath, yPath, 3);
    }
    </src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Colorful!</msg>
            <src>    
    &lt;bc:blue&gt;private static final Color CLR_ARROW_FILL   = new Color(240, 240, 240);
    private static final Color CLR_ARROW_BORDER = new Color(220, 220, 220);&lt;/bc&gt;
    
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;

        int[] xPath = new int[] {x1, x2, x1};
        int[] yPath = new int[] {y1, y1, y2};

        g.setColor(CLR_ARROW_FILL);
        g.fillPolygon(xPath, yPath, 3);

        g.setColor(CLR_ARROW_BORDER);
        g.drawPolygon(xPath, yPath, 3);
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>No such thing as magic</msg>
            <src>    
    private static final Color CLR_ARROW_FILL   = new Color(240, 240, 240);
    private static final Color CLR_ARROW_BORDER = new Color(220, 220, 220);
    
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;

        int[] xPath = new int[] {x1, x2, x1};
        int[] yPath = new int[] {y1, y1, y2};

        g.setColor(CLR_ARROW_FILL);
        g.fillPolygon(xPath, yPath, &lt;bc:red&gt;3&lt;/bc&gt;);      &lt;bc:red&gt;// Unnecessary magic number&lt;/bc&gt;

        g.setColor(CLR_ARROW_BORDER);
        g.drawPolygon(xPath, yPath, &lt;bc:red&gt;3&lt;/bc&gt;);      &lt;bc:red&gt;// Unnecessary magic number&lt;/bc&gt;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Sneaky...</msg>
            <src>    
    private static final Color CLR_ARROW_FILL   = new Color(240, 240, 240);
    private static final Color CLR_ARROW_BORDER = new Color(220, 220, 220);
    
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;

        int[] xPath = new int[] {x1, x2, x1};
        int[] yPath = new int[] {y1, y1, y2};

        g.setColor(CLR_ARROW_FILL);
        g.fillPolygon(xPath, yPath, &lt;bc:blue&gt;xPath.length&lt;/bc&gt;);

        g.setColor(CLR_ARROW_BORDER);
        g.drawPolygon(xPath, yPath, &lt;bc:blue&gt;xPath.length&lt;/bc&gt;);
    }
    </src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Lay Color</msg>
            <src>
    private static final Color CLR_ARROW_FILL   = &lt;bc:blue&gt;Lay.clr(&quot;240&quot;)&lt;/bc&gt;;
    private static final Color CLR_ARROW_BORDER = &lt;bc:blue&gt;Lay.clr(&quot;220&quot;)&lt;/bc&gt;;
    
    private void paintUlTriangle(Graphics g, int dy) {
        int x1 = 1;
        int x2 = 8;
        int y1 = dy + 1;
        int y2 = dy + 8;

        int[] xPath = new int[] {x1, x2, x1};
        int[] yPath = new int[] {y1, y1, y2};

        g.setColor(CLR_ARROW_FILL);
        g.fillPolygon(xPath, yPath, xPath.length);

        g.setColor(CLR_ARROW_BORDER);
        g.drawPolygon(xPath, yPath, xPath.length);
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>X.extract map print</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Print map with rendering</msg>
            <src>
    for(Integer k : bundles.keySet()) {
        buffer.append(k + &quot; =&gt; &quot;);
        WebCrawlerJobSummaryState state = bundles.get(k);
        JavaObjectReflectionExtractor X = new JavaObjectReflectionExtractor(state);
        NonTerminal M = X.extract();
        FMapRenderer R = new StandardAMapRenderer();
        buffer.append(R.renderValue(M) + &quot;\n\n&quot;);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Thought process</msg>
            <src>
    for(Integer k : bundles.keySet()) {
        buffer.append(k + &quot; =&gt; &quot;);
        WebCrawlerJobSummaryState state = bundles.get(k);
        JavaObjectReflectionExtractor X = new JavaObjectReflectionExtractor(state);
        NonTerminal M = X.extract();
        FMapRenderer R = new StandardAMapRenderer();
        buffer.append(R.renderValue(M) + &quot;\n\n&quot;);
    }

    Thought process:
        I need to print all the key value pairs in this map.
        So I&apos;ll write a loop...
                     ...oh cool well I have the key right now,
           ....so I&apos;ll just print that.  Done!
        Then.. I guess I&apos;ll need that value now.  Uggh ok
             how do I get that?  Now I&apos;ll transform it.
          Aaaaand print that too!


    Too often, we write code that directly corresponds to the steps
    that we thought about to solve the problem.</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Map iteration</msg>
            <src>
    &lt;bc:blue&gt;for(Integer k : bundles.keySet()) {
        WebCrawlerJobSummaryState state = bundles.get(k);    // Standard map iteration pattern
                                                             // Slightly cleaner: I use this almost always.&lt;/bc&gt;
        buffer.append(k + &quot; =&gt; &quot;);
        JavaObjectReflectionExtractor X = new JavaObjectReflectionExtractor(state);
        NonTerminal M = X.extract();
        FMapRenderer R = new StandardAMapRenderer();
        buffer.append(R.renderValue(M) + &quot;\n\n&quot;);
    }

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Map iteration (x2)</msg>
            <src>
    &lt;bc:blue&gt;for(Integer k : bundles.keySet()) {
        WebCrawlerJobSummaryState state = bundles.get(k);    // Standard map iteration pattern
                                                             // Slightly cleaner: I use this almost always.&lt;/bc&gt;
        buffer.append(k + &quot; =&gt; &quot;);
        JavaObjectReflectionExtractor X = new JavaObjectReflectionExtractor(state);
        NonTerminal M = X.extract();
        FMapRenderer R = new StandardAMapRenderer();
        buffer.append(R.renderValue(M) + &quot;\n\n&quot;);
    }



    &lt;bc:blue&gt;for(Entry&lt;Integer, WebCrawlerJobSummaryState&gt; entry : bundles.entrySet()) {
        Integer k = entry.getKey();
        WebCrawlerJobSummaryState state = entry.getValue();   // And this is the other common one
                                                              // Slightly faster: use this if map iteration is your performance bottleneck.&lt;/bc&gt;
        buffer.append(k + &quot; =&gt; &quot;);
        JavaObjectReflectionExtractor X = new JavaObjectReflectionExtractor(state);
        NonTerminal M = X.extract();
        FMapRenderer R = new StandardAMapRenderer();
        buffer.append(R.renderValue(M) + &quot;\n\n&quot;);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Organized</msg>
            <src>
    for(Integer k : bundles.keySet()) {
        WebCrawlerJobSummaryState state = bundles.get(k);

        JavaObjectReflectionExtractor X = new JavaObjectReflectionExtractor(state);
        NonTerminal M = X.extract();
        FMapRenderer R = new StandardAMapRenderer();

        &lt;bc:blue&gt;buffer.append(k + &quot; =&gt; &quot;);
        buffer.append(R.renderValue(M) + &quot;\n\n&quot;);&lt;/bc&gt;
    }
    </src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Buffer used correctly</msg>
            <src>
    for(Integer &lt;bc:blue&gt;nodeId&lt;/bc&gt; : bundles.keySet()) {
        WebCrawlerJobSummaryState state = bundles.get(&lt;bc:blue&gt;nodeId&lt;/bc&gt;);

        JavaObjectReflectionExtractor X = new JavaObjectReflectionExtractor(state);
        NonTerminal M = X.extract();
        FMapRenderer R = new StandardAMapRenderer();   // Move this out

        &lt;bc:blue&gt;buffer.append(nodeId);
        buffer.append(&quot; =&gt; &quot;);
        buffer.append(R.renderValue(M));
        buffer.append(&quot;\n\n&quot;);&lt;/bc&gt;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Button Alignment</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Let&apos;s Align</msg>
            <src>
    btnSet = Lay.btn(&quot;&amp;Default&quot;, ImageLib.get(&quot;action.png&quot;)),
    btnSave = Lay.btn(&quot;&amp;Save&quot;, ImageLib.get(&quot;save.gif&quot;)),
    btnLoad = Lay.btn(&quot;&amp;Load&quot;, ImageLib.get(&quot;open.gif&quot;)),
    btnCheckDep = Lay.btn(&quot;&amp;Test&quot;, ImageLib.get(&quot;dep.gif&quot;)),
    btnCheckBean = Lay.btn(&quot;&amp;Inspect&quot;, ImageLib.get(&quot;mag.gif&quot;)),
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>No...</msg>
            <src>
    btnSet = Lay.btn(      &quot;&amp;Default&quot;,  ImageLib.get(&quot;action.png&quot;)),
    btnSave = Lay.btn(     &quot;&amp;Save&quot;,     ImageLib.get(&quot;save.gif&quot;)),
    btnLoad = Lay.btn(     &quot;&amp;Load&quot;,     ImageLib.get(&quot;open.gif&quot;)),
    btnCheckDep = Lay.btn( &quot;&amp;Test&quot;,     ImageLib.get(&quot;dep.gif&quot;)),
    btnCheckBean = Lay.btn(&quot;&amp;Inspect&quot;,  ImageLib.get(&quot;mag.gif&quot;)),
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>???</msg>
            <src>
    btnSet       = Lay.btn(&quot;&amp;Default&quot;   ,  ImageLib.get(&quot;action.png&quot;)),
    btnSave      = Lay.btn(&quot;&amp;Save&quot;      ,  ImageLib.get(&quot;save.gif&quot;)),
    btnLoad      = Lay.btn(&quot;&amp;Load&quot;      ,  ImageLib.get(&quot;open.gif&quot;)),
    btnCheckDep  = Lay.btn(&quot;&amp;Test&quot;      ,  ImageLib.get(&quot;dep.gif&quot;)),
    btnCheckBean = Lay.btn(&quot;&amp;Inspect&quot;   ,  ImageLib.get(&quot;mag.gif&quot;)),
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Nope!</msg>
            <src>
    btnSet       = Lay.btn(&quot;&amp;Default&quot;,  ImageLib.get(&quot;action.png&quot;)),
    btnSave      = Lay.btn(&quot;&amp;Save&quot;,     ImageLib.get(&quot;save.gif&quot;)  ),
    btnLoad      = Lay.btn(&quot;&amp;Load&quot;,     ImageLib.get(&quot;open.gif&quot;)  ),
    btnCheckDep  = Lay.btn(&quot;&amp;Test&quot;,     ImageLib.get(&quot;dep.gif&quot;)   ),
    btnCheckBean = Lay.btn(&quot;&amp;Inspect&quot;,  ImageLib.get(&quot;mag.gif&quot;)   ),
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>There You Go</msg>
            <src>
    btnSet       = Lay.btn(&quot;&amp;Default&quot;,  ImageLib.get(&quot;action.png&quot;)),
    btnSave      = Lay.btn(&quot;&amp;Save&quot;,     ImageLib.get(&quot;save.gif&quot;)),
    btnLoad      = Lay.btn(&quot;&amp;Load&quot;,     ImageLib.get(&quot;open.gif&quot;)),
    btnCheckDep  = Lay.btn(&quot;&amp;Test&quot;,     ImageLib.get(&quot;dep.gif&quot;)),
    btnCheckBean = Lay.btn(&quot;&amp;Inspect&quot;,  ImageLib.get(&quot;mag.gif&quot;)),

    &lt;bc:blue&gt;// Only sensible alignment if you&apos;re going to do it.&lt;/bc&gt;</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Switch Alignment</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Any Thoughts?</msg>
            <src>
    switch(context.getAction()) {
        case CREATE:
            topMessage = &quot;Please provide the parameters for this job.&quot;;
            break;
        case UPDATE:
            topMessage = &quot;You may change the parameters for this job.&quot;;
            break;
        default:
            topMessage = &quot;These are the parameters for this job&quot;;
            break;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Right! This Switch Primed For Alignment</msg>
            <src>
    switch(context.getAction()) {
        case CREATE: topMessage = &quot;Please provide the parameters for this job.&quot;; break;
        case UPDATE: topMessage = &quot;You may change the parameters for this job.&quot;; break;
        default:     topMessage = &quot;These are the parameters for this job&quot;;       break;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Easier to Spot Errors and Inconsistencies</msg>
            <src>
    switch(context.getAction()) {
        case CREATE: topMessage = &quot;Please provide the parameters for this job.&quot;; break;
        case UPDATE: topMessage = &quot;You may change the parameters for this job.&quot;; break;
        &lt;c:red&gt;default:     topMessage = &quot;These are the parameters for this job&quot;;       break;&lt;/c&gt;
    }

    &lt;c:red&gt;// Where&apos;s the period?&lt;/c&gt;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>All Better</msg>
            <src>
    switch(context.getAction()) {
        case CREATE: topMessage = &quot;Please provide the parameters for this job.&quot;; break;
        case UPDATE: topMessage = &quot;You may change the parameters for this job.&quot;; break;
        default:     topMessage = &quot;These are the parameters for this job&lt;bc:blue&gt;.&lt;/bc&gt;&quot;;      break;
    }                                                                   &lt;bc:blue&gt;^ Added&lt;/bc&gt;
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Frame Closing Listener</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Nothing wrong here right??</msg>
            <src>    
    GotStyleFrame fra = new GotStyleFrame(model);
    fra.setVisible(true);
    fra.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>What about a dialog?</msg>
            <src>
    RuleEditDialog dlg = new RuleEditDialog(parent, rule);
    dlg.setVisible(true);
    dlg.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Now there&apos;s a problem....</msg>
            <src>
    RuleEditDialog dlg = new RuleEditDialog(parent, rule);
    dlg.setVisible(true);
    &lt;bc:red&gt;dlg.addClosingListener(e -&gt; {       // Will not execute until user closes dialog
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });&lt;/bc&gt;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Now the dialog will work!</msg>
            <src>
    RuleEditDialog dlg = new RuleEditDialog(parent, rule);
    &lt;bc:blue&gt;dlg.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });&lt;/bc&gt;
    dlg.setVisible(true);
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>So what about this one again?</msg>
            <src>    
    GotStyleFrame fra = new GotStyleFrame(model);
    fra.setVisible(true);
    fra.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });

</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Let&apos;s be consistent!</msg>
            <src>    
    GotStyleFrame fra = new GotStyleFrame(model);
    fra.setVisible(true);
    &lt;bc:red&gt;fra.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });&lt;/bc&gt;

</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Let&apos;s be consistent!</msg>
            <src>    
    GotStyleFrame fra = new GotStyleFrame(model);
    &lt;bc:blue&gt;fra.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });&lt;/bc&gt;
    fra.setVisible(true);

</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Organized, too!</msg>
            <src>    
    &lt;bc:blue&gt;// Construction and configuration&lt;/bc&gt;
    GotStyleFrame fra = new GotStyleFrame(model);
    fra.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });

    &lt;bc:blue&gt;// Usage&lt;/bc&gt;
    fra.setVisible(true);

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>What&apos;s wrong with this again?</msg>
            <src>    
    GotStyleFrame fra = new GotStyleFrame(model);
    fra.setVisible(true);
    fra.addClosingListener(e -&gt; {
        try {
            XStreamWrapper.writeToFile(model, data);
        } catch(Exception e1) {
            e1.printStackTrace();
        }
    });

</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Variable Name</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Thoughts?</msg>
            <src>
    s = &quot;It is not a requirement that general parameters be fun.&quot;;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Just Fine!</msg>
            <src>
    &lt;c:blue&gt;s = &quot;It is not a requirement that general parameters be fun.&quot;;&lt;/c&gt;
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Just a Little Line Wrap...</msg>
            <src>
    s = &quot;It is not a requirement that general parameters have no &quot; +
    &quot;connection with discovery or evaluation components.&quot;;</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Are you kidding me?</msg>
            <src>
    s = &quot;It is not a requirement that general parameters have no &quot; +
    &lt;c:red&gt;&quot;connection with discovery or evaluation components.&quot;;&lt;/c&gt;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Phew Better... right?</msg>
            <src>
    s = &quot;It is not a requirement that general parameters have no &quot; +
        &quot;connection with discovery or evaluation components.&quot;;

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Looks Clean to me</msg>
            <src>
    s = &quot;It is not a requirement that general parameters have no &quot; +
        &quot;connection with discovery or evaluation components.  In &quot; +
        &quot;fact, general parameters may involve subsystems which &quot; +
        &quot;are not specific to either discovery or evaluation, but which &quot; +
        &quot;act as services for any system component which might engage &quot; +
        &quot;those services (e.g. Rules, Stop).&quot;;
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>NO!</msg>
            <src>
    &lt;c:red&gt;s = &quot;It is not a requirement that general parameters have no &quot;
        + &quot;connection with discovery or evaluation components.  In &quot;
        + &quot;fact, general parameters may involve subsystems which &quot;
        + &quot;are not specific to either discovery or evaluation, but which &quot;
        + &quot;act as services for any system component which might engage &quot;
        + &quot;those services (e.g. Rules, Stop).&quot;;&lt;/c&gt;
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>ALSO NO!!</msg>
            <src>
    &lt;c:red&gt;s = &quot;It is not a requirement that general parameters have no &quot;
      + &quot;connection with discovery or evaluation components.  In &quot;
      + &quot;fact, general parameters may involve subsystems which &quot;
      + &quot;are not specific to either discovery or evaluation, but which &quot;
      + &quot;act as services for any system component which might engage &quot;
      + &quot;those services (e.g. Rules, Stop).&quot;;&lt;/c&gt;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>NICE!!</msg>
            <src>
    s = &quot;It is not a requirement that general parameters have no &quot;       &lt;c:blue&gt;+&lt;/c&gt;
        &quot;connection with discovery or evaluation components.  In &quot;       &lt;c:blue&gt;+&lt;/c&gt;
        &quot;fact, general parameters may involve subsystems which &quot;         &lt;c:blue&gt;+&lt;/c&gt;
        &quot;are not specific to either discovery or evaluation, but which &quot; &lt;c:blue&gt;+&lt;/c&gt;
        &quot;act as services for any system component which might engage &quot;   &lt;c:blue&gt;+&lt;/c&gt;
        &quot;those services (e.g. Rules, Stop).&quot;;
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>NO, NOT NICE!!</msg>
            <src>
    &lt;c:red&gt;s = &quot;It is not a requirement that general parameters have no &quot;       +
        &quot;connection with discovery or evaluation components.  In &quot;       +
        &quot;fact, general parameters may involve subsystems which &quot;         +
        &quot;are not specific to either discovery or evaluation, but which &quot; +
        &quot;act as services for any system component which might engage &quot;   +
        &quot;those services (e.g. Rules, Stop).&quot;;&lt;/c&gt;
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>One Letter Variables Uncommon</msg>
            <src>
    String msg = &quot;It is not a requirement that general parameters be fun.&quot;;
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Good Alignment!</msg>
            <src>
    String msg = &quot;It is not a requirement that general parameters have no &quot; +
                 &quot;connection with discovery or evaluation components.&quot;;

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Great Alignment!!</msg>
            <src>
    String msg = &quot;It is not a requirement that general parameters have no &quot; +
                 &quot;connection with discovery or evaluation components.  In &quot; +
                 &quot;fact, general parameters may involve subsystems which &quot; +
                 &quot;are not specific to either discovery or evaluation, but which &quot; +
                 &quot;act as services for any system component which might engage &quot; +
                 &quot;those services (e.g. Rules, Stop).&quot;;

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Amazing Alignment!!!</msg>
            <src>
    String generalHelpMessage = &quot;It is not a requirement that general parameters have no &quot; +
                                &quot;connection with discovery or evaluation components.  In &quot; +
                                &quot;fact, general parameters may involve subsystems which &quot; +
                                &quot;are not specific to either discovery or evaluation, but which &quot; +
                                &quot;act as services for any system component which might engage &quot; +
                                &quot;those services (e.g. Rules, Stop).&quot;;
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Super Duper Spectacular Alignment!!!!!!!!!</msg>
            <src>
    String generalHelpMessageEnglishVersion2EenyMeenyMinyMoe = &quot;It is not a requirement that general parameters have no &quot; +
                                                               &quot;connection with discovery or evaluation components.  In &quot; +
                                                               &quot;fact, general parameters may involve subsystems which &quot; +
                                                               &quot;are not specific to either discovery or evaluation, but which &quot; +
                                                               &quot;act as services for any system component which might engage &quot; +
                                                               &quot;those services (e.g. Rules, Stop).&quot;;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Phew, Was getting a little crazy</msg>
            <src>
    String generalHelpMessageEnglishVersion2EenyMeenyMinyMoe = 
        &quot;It is not a requirement that general parameters have no &quot; +
        &quot;connection with discovery or evaluation components.  In &quot; +
        &quot;fact, general parameters may involve subsystems which &quot; +
        &quot;are not specific to either discovery or evaluation, but which &quot; +
        &quot;act as services for any system component which might engage &quot; +
        &quot;those services (e.g. Rules, Stop).&quot;;

</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Nice</msg>
            <src>
    String msg = 
        &quot;It is not a requirement that general parameters have no &quot; +
        &quot;connection with discovery or evaluation components.  In &quot; +
        &quot;fact, general parameters may involve subsystems which &quot; +
        &quot;are not specific to either discovery or evaluation, but which &quot; +
        &quot;act as services for any system component which might engage &quot; +
        &quot;those services (e.g. Rules, Stop).&quot;;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Finally</msg>
            <src>
    String msg = 
        &quot;It is not a requirement that general parameters have no &quot;       &lt;c:blue&gt;+&lt;/c&gt;
        &quot;connection with discovery or evaluation components.  In &quot;       &lt;c:blue&gt;+&lt;/c&gt;
        &quot;fact, general parameters may involve subsystems which &quot;         &lt;c:blue&gt;+&lt;/c&gt;
        &quot;are not specific to either discovery or evaluation, but which &quot; &lt;c:blue&gt;+&lt;/c&gt;
        &quot;act as services for any system component which might engage &quot;   &lt;c:blue&gt;+&lt;/c&gt;
        &quot;those services (e.g. Rules, Stop).&quot;;
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>But Don&apos;t Patronize Me!</msg>
            <src>
    &lt;c:red&gt;String msg = 
        &quot;It is not a requirement that general parameters be fun.&quot;;&lt;/c&gt;
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Nice</msg>
            <src>
    &lt;bc:blue&gt;String msg = &quot;It is not a requirement that general parameters be fun.&quot;;&lt;/c&gt;
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Doc Vector Image</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Any problems with this UI?</msg>
            <src>

    sdflak j</src>
            <img>docvec1.png</img>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Oh, was that missing?</msg>
            <src>NEWPAGE</src>
            <img>docvec2.png</img>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Blacklist Image</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>How is this UI?</msg>
            <src>NEWPAGE</src>
            <img>blacklist1.png</img>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Ah, missing header!</msg>
            <src>NEWPAGE</src>
            <img>blacklist2.png</img>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Possible future features</msg>
            <src>NEWPAGE</src>
            <img>blacklist3.png</img>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>setPreemptor</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Let&apos;s set a combo box&apos;s value...</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            }
            if(preemptor != null &amp;&amp; tuple.preemptor != null) {
                if(preemptor.getClass().equals(tuple.preemptor.getClass())) {
                    cboPreemptor.setSelectedItem(tuple);
                    break;
                }
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Sneaky useless condition</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            }
            if(preemptor != null &amp;&amp; &lt;bc:red&gt;tuple.preemptor != null&lt;/bc&gt;) {
                if(preemptor.getClass().equals(tuple.preemptor.getClass())) {
                    cboPreemptor.setSelectedItem(tuple);
                    break;
                }
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            &lt;bc:blue&gt;} else {&lt;/bc&gt;
                if(preemptor != null) {
                    if(preemptor.getClass().equals(tuple.preemptor.getClass())) {
                        cboPreemptor.setSelectedItem(tuple);
                        break;
                    }
                }
            &lt;bc:blue&gt;}&lt;/bc&gt;
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            } else {
                &lt;bc:red&gt;if(preemptor != null) {&lt;/bc&gt;
                    if(preemptor.getClass().equals(tuple.preemptor.getClass())) {
                        cboPreemptor.setSelectedItem(tuple);
                        break;
                    }
                }
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            } else &lt;bc:blue&gt;if(preemptor != null) {&lt;/bc&gt;
                if(preemptor.getClass().equals(tuple.preemptor.getClass())) {
                    cboPreemptor.setSelectedItem(tuple);
                    break;
                }
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            } else &lt;bc:blue&gt;if(preemptor != null) {&lt;/bc&gt;
                &lt;bc:red&gt;if(preemptor.getClass().equals(tuple.preemptor.getClass())) {&lt;/bc&gt;
                    cboPreemptor.setSelectedItem(tuple);
                    break;
                }
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            &lt;bc:blue&gt;} else if(preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())) {&lt;/bc&gt;
                cboPreemptor.setSelectedItem(tuple);
                break;
            &lt;bc:blue&gt;}&lt;/bc&gt;
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            &lt;bc:blue&gt;} else if(preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())) {&lt;/bc&gt;
                cboPreemptor.setSelectedItem(tuple);
                break;
            &lt;bc:blue&gt;}&lt;/bc&gt;
        }
    }

    &lt;bc:blue&gt;
    // Doesn&apos;t matter if previous was cleaner, because this is such a well known
    // pattern to developers, you want to make it clearly convey that pattern.
    // For example:

        if(node != null &amp;&amp; node.getContext() != null) {    // Everyone recognizes this &apos;gating&apos; pattern
            ...
        }
    &lt;/bc&gt;</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Any symmetry issues?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
            } else if(preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())) {
                cboPreemptor.setSelectedItem(tuple);
                break;
            }
        }
    }

    &lt;bc:blue&gt;// Assume only 1 tuple in the combo box&apos;s model can have a null (&quot;(NONE)&quot;) preemptor...&lt;/bc&gt;</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                cboPreemptor.setSelectedItem(tuple);
                &lt;bc:red&gt;break;    // Where was this?  Technically was optional, but if you insert it....&lt;/bc&gt;
            } else if(preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())) {
                cboPreemptor.setSelectedItem(tuple);
                break;
            }
        }
    }

    &lt;bc:blue&gt;// Assume only 1 tuple in the combo box&apos;s model can have a null (&quot;(NONE)&quot;) preemptor...&lt;/bc&gt;</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null) {
                &lt;bc:red&gt;cboPreemptor.setSelectedItem(tuple);       // Same Code!
                break;&lt;/bc&gt;
            } else if(preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())) {
                &lt;bc:red&gt;cboPreemptor.setSelectedItem(tuple);
                break;&lt;/bc&gt;
            }                                
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>?</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            &lt;bc:blue&gt;if(tuple.preemptor == null || preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())) {
                cboPreemptor.setSelectedItem(tuple);
                break;
            }&lt;/bc&gt;
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Shorter and Still Comprehensible</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if(tuple.preemptor == null || 
                    &lt;bc:blue&gt;preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())) {&lt;/bc&gt;
                cboPreemptor.setSelectedItem(tuple);
                break;
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Unnecessary Parentheses</msg>
            <src>
    private void setPreemptor(HttpRequestPreemptor preemptor) {
        for(int e = 0; e &lt; mdlPreemptor.getSize(); e++) {
            HttpRequestPreemptorTuple tuple = mdlPreemptor.getElementAt(e);
            if((tuple.preemptor == null) || 
                    &lt;bc:red&gt;(&lt;/bc&gt;preemptor != null &amp;&amp; preemptor.getClass().equals(tuple.preemptor.getClass())&lt;bc:red&gt;)&lt;/bc&gt;) {
                cboPreemptor.setSelectedItem(tuple);
                break;
            }
        }
    }

    &lt;bc:red&gt;// No superfluous parentheses here!  Remember, || much WEAKER than &amp;&amp;
    // Especially given the formatting above, there is no confusion about
    // order of operations.&lt;/bc&gt;


   int x = ((a * b) + c)


</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Notes Style</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Style Doesn&apos;t Just Affect Code!</msg>
            <src>
    - [Empty Params Class]
    - [1 SS Field]

    - [Empty Params Class]
    - [No SS Class yet]

    - [1 P Field]
    - [1 SS Field]

    - [Empty Params Class]
    - [5 SS Fields]

    - [Empty Params Class]
    - [No SS Class yet]




</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Cleaned Up.  Ask, &quot;what am I describing?&quot;</msg>
            <src>
    - [Params: Empty]
    - [SS: 1 Field]

    - [Params: Empty]
    - [SS: None]

    - [Params: 1 Field]
    - [SS: 1 Field]

    - [Params: Empty]
    - [SS: 5 Fields]

    - [Params: Empty]
    - [SS: None]
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>DEFAULT_DOWNLOADERS</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Some Simple FIeld Declarations</msg>
            <src>
    public class DownloadSubsystemParams extends WebCrawlingDiscoverySourceSubsystemParams {


        ////////////
        // FIELDS //
        ////////////

        // Defaults

        public static final int                DEFAULT_DOWNLOADERS          = 2;
        public static final HttpRequestOptions DEFAULT_HTTP_REQUEST_OPTIONS = new HttpRequestOptions();

        // Core

        private int                numDownloaders     = DEFAULT_DOWNLOADERS;
        private HttpRequestOptions httpRequestOptions = DEFAULT_HTTP_REQUEST_OPTIONS;

        ...
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Semantic mismatch!</msg>
            <src>
    public class DownloadSubsystemParams extends WebCrawlingDiscoverySourceSubsystemParams {


        ////////////
        // FIELDS //
        ////////////

        // Defaults

        public static final int                &lt;bc:red&gt;DEFAULT_DOWNLOADERS&lt;/bc&gt;          = 2;
        public static final HttpRequestOptions DEFAULT_HTTP_REQUEST_OPTIONS = new HttpRequestOptions();

        // Core

        private int                numDownloaders     = &lt;bc:red&gt;DEFAULT_DOWNLOADERS&lt;/bc&gt;;
        private HttpRequestOptions httpRequestOptions = DEFAULT_HTTP_REQUEST_OPTIONS;

        ...
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Words Imply Data Types!</msg>
            <src>
    public class DownloadSubsystemParams extends WebCrawlingDiscoverySourceSubsystemParams {


        ////////////
        // FIELDS //
        ////////////

        // Defaults

        public static final int                DEFAULT_&lt;bc:blue&gt;NUM_&lt;/bc&gt;DOWNLOADERS      = 2;
        public static final HttpRequestOptions DEFAULT_HTTP_REQUEST_OPTIONS = new HttpRequestOptions();

        // Core

        private int                numDownloaders     = DEFAULT_&lt;bc:blue&gt;NUM_&lt;/bc&gt;DOWNLOADERS;
        private HttpRequestOptions httpRequestOptions = DEFAULT_HTTP_REQUEST_OPTIONS;

        ...
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>&quot;Downloader&quot; is an object!</msg>
            <src>
    public class DownloadSubsystemParams extends WebCrawlingDiscoverySourceSubsystemParams {


        ////////////
        // FIELDS //
        ////////////

        // Defaults

        public static final &lt;bc:blue&gt;List&lt;Downloader&gt;   DEFAULT_DOWNLOADERS          = new ArrayList&lt;&gt;();&lt;/bc&gt;
        public static final HttpRequestOptions DEFAULT_HTTP_REQUEST_OPTIONS = new HttpRequestOptions();

        // Core

        private &lt;bc:blue&gt;List&lt;Downloader&gt;   downloaders        = DEFAULT_DOWNLOADERS;&lt;/bc&gt;
        private HttpRequestOptions httpRequestOptions = DEFAULT_HTTP_REQUEST_OPTIONS;

        ...
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Blank Params Panel</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>A Blank Extractor Params Panel</msg>
            <src>
    public class PlagiarismHashesExtractorParamsPanel 
            extends ExtractorParamsPanel&lt;PlagiarismHashesExtractorParams&gt; {
    
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public PlagiarismHashesExtractorParamsPanel(JobParamsWindowContext context) {
            Lay.GBLtg(this,
                Lay.lb(WebCrawlerJobParamsPanel.NO_PARAMS)
            );
        }
    
        @Override
        public PlagiarismHashesExtractorParams get() {
            return new PlagiarismHashesExtractorParams();
        }
    
        @Override
        public void set(PlagiarismHashesExtractorParams params) {
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Another Blank Extractor Params Panel</msg>
            <src>
    public class RelevanceDocVectorExtractorParamsPanel 
            extends ExtractorParamsPanel&lt;RelevanceDocVectorExtractorParams&gt; {
    
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public RelevanceDocVectorExtractorParamsPanel(JobParamsWindowContext context) {
            Lay.GBLtg(this,
                Lay.lb(WebCrawlerJobParamsPanel.NO_PARAMS)
            );
        }
    
        @Override
        public RelevanceDocVectorExtractorParams get() {
            return new RelevanceDocVectorExtractorParams();
        }
    
        @Override
        public void set(RelevanceDocVectorExtractorParams params) {
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>And Another Blank Extractor Params Panel</msg>
            <src>
    public class TextExtractorParamsPanel 
            extends ExtractorParamsPanel&lt;TextExtractorParams&gt; {
    
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public TextExtractorParamsPanel(JobParamsWindowContext context) {
            Lay.GBLtg(this,
                Lay.lb(WebCrawlerJobParamsPanel.NO_PARAMS)
            );
        }
    
        @Override
        public TextExtractorParams get() {
            return new TextExtractorParams();
        }
    
        @Override
        public void set(TextExtractorParams params) {
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Let&apos;s Use Generics!</msg>
            <src>
    public class &lt;bc:blue&gt;NoParameters&lt;/bc&gt;ExtractorParamsPanel&lt;bc:blue&gt;&lt;P extends ExtractorParams&gt;&lt;/bc&gt;
            extends ExtractorParamsPanel&lt;&lt;bc:blue&gt;P&lt;/bc&gt;&gt; {
    
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public NoParametersExtractorParamsPanel(JobParamsWindowContext context) {
            Lay.GBLtg(this,
                Lay.lb(WebCrawlerJobParamsPanel.NO_PARAMS)
            );
        }
    
        @Override
        public &lt;bc:blue&gt;P&lt;/bc&gt; get() {
            return &lt;bc:red&gt;??????&lt;/bc&gt;;
        }
    
        @Override
        public void set(&lt;bc:blue&gt;P&lt;/bc&gt; params) {
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public class NoParametersExtractorParamsPanel&lt;P extends ExtractorParams&gt;
            extends ExtractorParamsPanel&lt;P&gt; {
    
    
        &lt;bc:blue&gt;///////////
        // FIELD //
        ///////////
    
        private ExtractorGenerator&lt;P&gt; generator;&lt;/bc&gt;
    
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public NoParametersExtractorParamsPanel(JobParamsWindowContext context, 
                                                &lt;bc:blue&gt;ExtractorGenerator&lt;P&gt; generator&lt;/bc&gt;) {
            &lt;bc:blue&gt;this.generator = generator;&lt;/bc&gt;
    
            Lay.GBLtg(this,
                Lay.lb(WebCrawlerJobParamsPanel.NO_PARAMS)
            );
        }
    
        @Override
        public P get() {
            return ??????;
        }
    
        @Override
        public void set(P params) {
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>?</msg>
            <src>
    public class NoParametersExtractorParamsPanel&lt;P extends ExtractorParams&gt;
            extends ExtractorParamsPanel&lt;P&gt; {
    
    
        ///////////
        // FIELD //
        ///////////
    
        private ExtractorGenerator&lt;P&gt; generator;
    
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public NoParametersExtractorParamsPanel(JobParamsWindowContext context, 
                                                ExtractorGenerator&lt;P&gt; generator) {
            this.generator = generator;
    
            Lay.GBLtg(this,
                Lay.lb(WebCrawlerJobParamsPanel.NO_PARAMS)
            );
        }
    
        @Override
        public P get() {
            return &lt;bc:blue&gt;generator.createParams()&lt;/bc&gt;;
        }
    
        @Override
        public void set(P params) {
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>?</msg>
            <src>
    public class NoParametersExtractorParamsPanel&lt;P extends ExtractorParams&gt;
            extends ExtractorParamsPanel&lt;P&gt; {
    
    
        ///////////
        // FIELD //
        ///////////
    
        private ExtractorGenerator&lt;P&gt; generator;
    
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public NoParametersExtractorParamsPanel(JobParamsWindowContext context, 
                                                ExtractorGenerator&lt;P&gt; generator) {
            this.generator = generator;
    
            Lay.GBLtg(this,
                Lay.lb(WebCrawlerJobParamsPanel.NO_PARAMS)
            );
        }
    
    
        &lt;bc:blue&gt;//////////////////////////
        // ACCESSORS / MUTATORS //
        //////////////////////////
    
        // Accessor&lt;/bc&gt;
    
        @Override
        public P get() {
            return generator.createParams();
        }
    
        &lt;bc:blue&gt;// Mutator&lt;/bc&gt;
    
        @Override
        public void set(P params) {
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Easy Generator Fix</msg>
            <src>
    @Override
    public BeanPanel&lt;TextExtractorParams&gt; createParamsPanel(JobParamsWindowContext context) {
        return new TextExtractorParamsPanel(context);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Easy Generator Fix</msg>
            <src>
    @Override
    public BeanPanel&lt;TextExtractorParams&gt; createParamsPanel(JobParamsWindowContext context) {
        return new &lt;bc:blue&gt;NoParametersExtractorParamsPanel&lt;/bc&gt;(context, &lt;bc:blue&gt;this&lt;/bc&gt;);
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>/home/dd/avondale dir</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Simple directory listing</msg>
            <src>
    /home/dd/avondale
        analyze-logs
        app_stable
        archive
        clear-db
        clear-logs
        conf
        redeploy
        service
        start-client
        start-server
        version
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Easier to read</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;app_stable&lt;/bc&gt;/
        &lt;bc:blue&gt;archive&lt;/bc&gt;/
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Why is that the problem?</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Why is that the problem?</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;           // Hint: ADJECTIVE &apos;stable&apos; modifies NOUN &apos;app&apos;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/              // Question: What &lt;bu&gt;OTHER&lt;/bu&gt; types of &apos;app&apos; are there?
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Wait, what&apos;s the problem??</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;           // Hint: ADJECTIVE &apos;stable&apos; modifies NOUN &apos;app&apos;
        &lt;bc:red&gt;app_stablerc/&lt;/bc&gt;         // Question: What &lt;bu&gt;OTHER&lt;/bu&gt; types of &apos;app&apos; are there?
        &lt;bc:red&gt;app_test/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/             
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Still not toooo bad...</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_experiment/&lt;/bc&gt;
        &lt;bc:red&gt;app_ldrd/&lt;/bc&gt;
        &lt;bc:red&gt;app_quickfix/&lt;/bc&gt;
        &lt;bc:red&gt;app_quickfix2/&lt;/bc&gt;
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;           // Hint: ADJECTIVE &apos;stable&apos; modifies NOUN &apos;app&apos;
        &lt;bc:red&gt;app_stablerc/&lt;/bc&gt;         // Question: What &lt;bu&gt;OTHER&lt;/bu&gt; types of &apos;app&apos; are there?
        &lt;bc:red&gt;app_test/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/             
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Oh, should have seen that coming</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_2_0_0_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_2_0_2_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160301/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160401/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160501/        // O(N) growth in # of children in /home/dd/avondale!&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160722/&lt;/bc&gt;        
        &lt;bc:red&gt;app_broken_as_fug/&lt;/bc&gt;          
        &lt;bc:red&gt;app_experiment/&lt;/bc&gt;             
        &lt;bc:red&gt;app_fix_3_1_0/&lt;/bc&gt;              
        &lt;bc:red&gt;app_fix_4_0_0/&lt;/bc&gt;              
        &lt;bc:red&gt;app_for_dave/&lt;/bc&gt;               
        &lt;bc:red&gt;app_ldrd/&lt;/bc&gt;                   
        &lt;bc:red&gt;app_memory_leak/&lt;/bc&gt;            
        &lt;bc:red&gt;app_quickfix/&lt;/bc&gt;               
        &lt;bc:red&gt;app_quickfix2/&lt;/bc&gt;
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;                 
        &lt;bc:red&gt;app_stable_old/&lt;/bc&gt;             
        &lt;bc:red&gt;app_stable_old_bk/&lt;/bc&gt;
        &lt;bc:red&gt;app_stablerc/&lt;/bc&gt;
        &lt;bc:red&gt;app_start/&lt;/bc&gt;
        &lt;bc:red&gt;app_test/&lt;/bc&gt;
        &lt;bc:red&gt;app_your_vers/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/             
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_2_0_0_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_2_0_2_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160301/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160401/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160501/        // O(N) growth in # of children in /home/dd/avondale!&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160722/&lt;/bc&gt;        
        &lt;bc:red&gt;app_broken_as_fug/          // Consequences:&lt;/bc&gt;
        &lt;bc:red&gt;app_experiment/             //   * Hard to distinguish which children are which&lt;/bc&gt;
        &lt;bc:red&gt;app_fix_3_1_0/              //   * Mixing types of children unnecessarily (scripts v. dirs)&lt;/bc&gt;
        &lt;bc:red&gt;app_fix_4_0_0/&lt;/bc&gt;              
        &lt;bc:red&gt;app_for_dave/&lt;/bc&gt;               
        &lt;bc:red&gt;app_ldrd/&lt;/bc&gt;                   
        &lt;bc:red&gt;app_memory_leak/&lt;/bc&gt;            
        &lt;bc:red&gt;app_quickfix/&lt;/bc&gt;               
        &lt;bc:red&gt;app_quickfix2/&lt;/bc&gt;
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;                 
        &lt;bc:red&gt;app_stable_old/&lt;/bc&gt;             
        &lt;bc:red&gt;app_stable_old_bk/&lt;/bc&gt;
        &lt;bc:red&gt;app_stablerc/&lt;/bc&gt;
        &lt;bc:red&gt;app_start/&lt;/bc&gt;
        &lt;bc:red&gt;app_test/&lt;/bc&gt;
        &lt;bc:red&gt;app_your_vers/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/             
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    /home/dd/avondale
        analyze-logs
        app_2_0_0_legacy
        app_2_0_2_legacy
        app_branch_20160301
        app_branch_20160401
        app_branch_20160501        // O(N) growth in # of children in /home/dd/avondale!
        app_branch_20160722        
        app_broken_as_fug          // Consequences:
        app_experiment             //   * Hard to distinguish which children are which
        app_fix_3_1_0              //   * Mixing types of children unnecessarily (scripts v. dirs)
        app_fix_4_0_0              
        app_for_dave
        app_ldrd
        app_memory_leak
        app_quickfix
        app_quickfix2
        app_stable
        app_stable_old
        app_stable_old_bk
        app_stablerc
        app_start
        app_test
        app_your_vers
        archive             
        clear-db
        clear-logs
        conf
        redeploy
        service
        start-client
        start-server
        version
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    /home/dd/avondale
        analyze-logs
        app_2_0_0_legacy
        app_2_0_2_legacy
        app_branch_20160301
        app_branch_20160401
        app_branch_20160501        // O(N) growth in # of children in /home/dd/avondale!
        app_branch_20160722        
        app_broken_as_fug          // Consequences:
        app_experiment             //   * Hard to distinguish which children are which
        app_fix_3_1_0              //   * Mixing types of children unnecessarily (scripts v. dirs)
        app_fix_4_0_0              
        app_for_dave
        app_ldrd
        app_memory_leak
        app_quickfix
        app_quickfix2
        app_stable
        app_stable_old
        app_stable_old_bk
        app_stablerc
        &lt;bc:red&gt;app_start*&lt;/bc&gt;                 // Actually was a script!
        app_test
        app_your_vers
        archive             
        clear-db
        clear-logs
        conf
        redeploy
        service
        start-client
        start-server
        version
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_2_0_0_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_2_0_2_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160301/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160401/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160501/&lt;/bc&gt;        // O(N) growth in # of children in /home/dd/avondale!
        &lt;bc:red&gt;app_branch_20160722/&lt;/bc&gt;        
        &lt;bc:red&gt;app_broken_as_fug/&lt;/bc&gt;          // Consequences:
        &lt;bc:red&gt;app_experiment/&lt;/bc&gt;             //   * Hard to distinguish which children are which
        &lt;bc:red&gt;app_fix_3_1_0/&lt;/bc&gt;              //   * Mixing types of children unnecessarily (scripts v. dirs)
        &lt;bc:red&gt;app_fix_4_0_0/&lt;/bc&gt;              
        &lt;bc:red&gt;app_for_dave/&lt;/bc&gt;               
        &lt;bc:red&gt;app_ldrd/&lt;/bc&gt;                   
        &lt;bc:red&gt;app_memory_leak/&lt;/bc&gt;            
        &lt;bc:red&gt;app_quickfix/&lt;/bc&gt;               
        &lt;bc:red&gt;app_quickfix2/&lt;/bc&gt;
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;                 
        &lt;bc:red&gt;app_stable_old/&lt;/bc&gt;             
        &lt;bc:red&gt;app_stable_old_bk/&lt;/bc&gt;
        &lt;bc:red&gt;app_stablerc/&lt;/bc&gt;
        &lt;bc:00C413&gt;app_start&lt;/bc&gt;*
        &lt;bc:red&gt;app_test/&lt;/bc&gt;
        &lt;bc:red&gt;app_your_vers/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/             
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Oh, should have seen that coming</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_2_0_0_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_2_0_2_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160301/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160401/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160501/&lt;/bc&gt;        // O(N) growth in # of children in /home/dd/avondale!
        &lt;bc:red&gt;app_branch_20160722/&lt;/bc&gt;        
        &lt;bc:red&gt;app_broken_as_fug/&lt;/bc&gt;          // Consequences:
        &lt;bc:red&gt;app_experiment/&lt;/bc&gt;             //   * Hard to distinguish which children are which
        &lt;bc:red&gt;app_fix_3_1_0/&lt;/bc&gt;              //   * Mixing types of children unnecessarily (scripts v. dirs)
        &lt;bc:red&gt;app_fix_4_0_0/&lt;/bc&gt;              //   * Flat hierarchy begets flat hierarchy
        &lt;bc:red&gt;app_for_dave/&lt;/bc&gt;               //       - What other structure are you willing to ignore?
        &lt;bc:red&gt;app_ldrd/&lt;/bc&gt;                   
        &lt;bc:red&gt;app_memory_leak/&lt;/bc&gt;            
        &lt;bc:red&gt;app_quickfix/&lt;/bc&gt;               
        &lt;bc:red&gt;app_quickfix2/&lt;/bc&gt;
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;                 
        &lt;bc:red&gt;app_stable_old/&lt;/bc&gt;             
        &lt;bc:red&gt;app_stable_old_bk/&lt;/bc&gt;
        &lt;bc:red&gt;app_stablerc/&lt;/bc&gt;
        &lt;bc:00C413&gt;app_start&lt;/bc&gt;*
        &lt;bc:red&gt;app_test/&lt;/bc&gt;
        &lt;bc:red&gt;app_your_vers/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/             
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:red&gt;app_2_0_0_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_2_0_2_legacy/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160301/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160401/&lt;/bc&gt;
        &lt;bc:red&gt;app_branch_20160501/&lt;/bc&gt;        // O(N) growth in # of children in /home/dd/avondale!
        &lt;bc:red&gt;app_branch_20160722/&lt;/bc&gt;        
        &lt;bc:red&gt;app_broken_as_fug/&lt;/bc&gt;          // Consequences:
        &lt;bc:red&gt;app_experiment/&lt;/bc&gt;             //   * Hard to distinguish which children are which
        &lt;bc:red&gt;app_fix_3_1_0/&lt;/bc&gt;              //   * Mixing types of children unnecessarily (scripts v. dirs)
        &lt;bc:red&gt;app_fix_4_0_0/&lt;/bc&gt;              //   * Flat hierarchy begets flat hierarchy
        &lt;bc:red&gt;app_for_dave/&lt;/bc&gt;               //       - What other structure are you willing to ignore?
        &lt;bc:red&gt;app_ldrd/&lt;/bc&gt;                   //   * Extra Work!
        &lt;bc:red&gt;app_memory_leak/&lt;/bc&gt;            //     * Time to code the ~10 scripts that expected app_* &lt;bu&gt;= 4 hours&lt;/bu&gt;
        &lt;bc:red&gt;app_quickfix/&lt;/bc&gt;               //     * Time to recode &amp; validate the ~10 scripts that
        &lt;bc:red&gt;app_quickfix2/&lt;/bc&gt;              //       expected app_* to ones that expect apps/         &lt;bu&gt;= 1 hour&lt;/bu&gt;
        &lt;bc:red&gt;app_stable/&lt;/bc&gt;                 
        &lt;bc:red&gt;app_stable_old/&lt;/bc&gt;             
        &lt;bc:red&gt;app_stable_old_bk/&lt;/bc&gt;
        &lt;bc:red&gt;app_stablerc/&lt;/bc&gt;
        &lt;bc:00C413&gt;app_start&lt;/bc&gt;*
        &lt;bc:red&gt;app_test/&lt;/bc&gt;
        &lt;bc:red&gt;app_your_vers/&lt;/bc&gt;
        &lt;bc:blue&gt;archive&lt;/bc&gt;/             
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>?</msg>
            <src>
    /home/dd/avondale
        &lt;bc:00C413&gt;analyze-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;apps&lt;/bc&gt;/            // Obvious, simple solution.
        &lt;bc:blue&gt;archive&lt;/bc&gt;/         //   * But this is such a COMMON data management problem,
        &lt;bc:00C413&gt;clear-db&lt;/bc&gt;*        //     we can learn from this, think ahead, and save some time!
        &lt;bc:00C413&gt;clear-logs&lt;/bc&gt;*
        &lt;bc:blue&gt;conf&lt;/bc&gt;/
        &lt;bc:00C413&gt;redeploy&lt;/bc&gt;*
        &lt;bc:blue&gt;service&lt;/bc&gt;/
        &lt;bc:00C413&gt;start-client&lt;/bc&gt;*
        &lt;bc:00C413&gt;start-server&lt;/bc&gt;*
        &lt;bc:00C413&gt;version&lt;/bc&gt;*
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>/home/dd/avondale/apps/X</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Quiz</msg>
            <src>
    /home/dd/avondale/apps/stable
        AvondaleClient.sh
        AvondaleServer.sh
        avondale.log
        avondale-platform.jar
        lib
        VERSION

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Quiz</msg>
            <src>
    /home/dd/avondale/apps/stable
        &lt;bc:blue&gt;AvondaleClient.bat&lt;/bc&gt;
        AvondaleClient.sh
        &lt;bc:blue&gt;AvondaleServer.bat&lt;/bc&gt;
        AvondaleServer.sh
        avondale.log
        avondale-platform.jar
        lib
        VERSION

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Quiz</msg>
            <src>
    /home/dd/avondale/apps/stable
        AvondaleClient.bat
        AvondaleClient.sh
        AvondaleServer.bat
        AvondaleServer.sh
        avondale.log
        avondale-platform.jar
        lib
        &lt;bc:blue&gt;security.log&lt;/bc&gt;
        VERSION

</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Quiz</msg>
            <src>
    /home/dd/avondale/apps/stable
        AvondaleClient.bat
        AvondaleClient.sh
        AvondaleServer.bat
        AvondaleServer.sh
        avondale.log
        &lt;bc:blue&gt;avondale.log.2016-08-31&lt;/bc&gt;
        avondale-platform.jar
        lib
        security.log
        &lt;bc:blue&gt;security.log.2016-08-31&lt;/bc&gt;
        VERSION
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Quiz</msg>
            <src>
    /home/dd/avondale/apps/stable
        AvondaleClient.bat
        AvondaleClient.sh
        AvondaleServer.bat
        AvondaleServer.sh
        avondale.log
        avondale.log.2016-08-31
        &lt;bc:blue&gt;avondale.log.2016-09-01&lt;/bc&gt;
        &lt;bc:blue&gt;avondale.log.2016-09-02&lt;/bc&gt;
        &lt;bc:blue&gt;avondale.log.2016-09-03&lt;/bc&gt;
        avondale-platform.jar
        lib
        security.log
        security.log.2016-08-31
        &lt;bc:blue&gt;security.log.2016-09-01&lt;/bc&gt;
        &lt;bc:blue&gt;security.log.2016-09-02&lt;/bc&gt;
        &lt;bc:blue&gt;security.log.2016-09-03&lt;/bc&gt;
        VERSION
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>GFS deleteAction</title>
        <pages>
          <Pg>
            <status>GOOD</status>
            <msg>Simple GridFS delete code</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);
                    status = &quot;Deleted 1 file.&quot;;
                }
            }
        } else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                        deleted++;
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }
        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Simple GridFS delete code</msg>
            <src>
    private static void deleteAction(DB db0, String col, &lt;bc:blue&gt;ObjectId id0, String fn&lt;/bc&gt;, boolean force) {        &lt;bc:blue&gt;// Can either delete a GridFS file using ID or File Name&lt;/bc&gt;
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);
                    status = &quot;Deleted 1 file.&quot;;
                }
            }
        } else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                        deleted++;
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }
        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Simple GridFS delete code</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        &lt;bc:blue&gt;if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);
                    status = &quot;Deleted 1 file.&quot;;
                }
            }&lt;/bc&gt;
        } else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                        deleted++;
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }
        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Simple GridFS delete code</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        &lt;bc:blue&gt;if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {         // Ask user to delete
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);                              // Just remove the given unique file
                    status = &quot;Deleted 1 file.&quot;;
                }
            }&lt;/bc&gt;
        } else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                        deleted++;
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }
        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Simple GridFS delete code</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);
                    status = &quot;Deleted 1 file.&quot;;
                }
            }
        &lt;bc:blue&gt;} else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                        deleted++;
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }&lt;/bc&gt;
        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Simple GridFS delete code</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);
                    status = &quot;Deleted 1 file.&quot;;
                }
            }
        &lt;bc:blue&gt;} else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {      // Ask user to delete
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));          // Since File Name not unique, iterate over results
                        deleted++;                                      // and remove using each file&apos;s ID
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }&lt;/bc&gt;
        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Simple GridFS delete code</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);
                    status = &quot;Deleted 1 file.&quot;;
                }
            }
        } else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                        deleted++;                            
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }
        &lt;bc:blue&gt;System.out.println(&quot;Delete: &quot; + status);          // Status message of what happened above&lt;/bc&gt;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Any improvements possible?</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        if(id0 != null) {
            int found = collection.find(new BasicDBObject(&quot;_id&quot;, id0), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with ID &apos;&quot; + id0 + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete 1 file&quot;)) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    GridFS gfs = new GridFS(db0, col);
                    gfs.remove(id0);
                    status = &quot;Deleted 1 file.&quot;;
                }
            }
        } else {
            int found = collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject()).size();
            if(found == 0) {
                status = &quot;No files found with file name &apos;&quot; + fn + &quot;&apos;.&quot;;
            } else {
                if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                    status = &quot;Delete canceled.&quot;;
                } else {
                    int deleted = 0;
                    for(DBObject obj : collection.find(new BasicDBObject(&quot;filename&quot;, fn), new BasicDBObject())) {
                        GridFS gfs = new GridFS(db0, col);
                        gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                        deleted++;                            
                    }
                    status = &quot;Deleted &quot; + deleted + &quot; file&quot; + StringUtil.s(deleted) + &quot;.&quot;;
                }
            }
        }
        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Nice reorganization - query | results</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        String fieldName;
        BasicDBObject fieldSelect = new BasicDBObject();
        BasicDBObject query;
        Object fieldVal;

        if(id0 != null) {
            fieldName = &quot;ID&quot;;
            fieldVal = id0;
            query = new BasicDBObject(&quot;_id&quot;, id0);
        } else {
            fieldName = &quot;file name&quot;;
            fieldVal = fn;
            query = new BasicDBObject(&quot;filename&quot;, fn);
        }

        DBCursor cursor = collection.find(query, fieldSelect);
        int found = cursor.size();
        if(found == 0) {
            status = &quot;No files found with &quot; + fieldName + &quot; &apos;&quot; + fieldVal + &quot;&apos;.&quot;;
        } else {
            if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                status = &quot;Delete canceled.&quot;;
            } else {
                GridFS gfs = new GridFS(db0, col);
                for(DBObject obj : cursor) {
                    gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                }
                status = &quot;Deleted &quot; + found + &quot; file&quot; + StringUtil.s(found) + &quot;.&quot;;
            }
        }

        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Can do more</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;
        String fieldName;
        BasicDBObject fieldSelect = new BasicDBObject();
        BasicDBObject query;
        Object fieldVal;

        if(id0 != null) {
            fieldName = &quot;ID&quot;;
            fieldVal = id0;
            &lt;bc:red&gt;query = new BasicDBObject(&quot;_id&quot;, id0);&lt;/bc&gt;
        } else {
            fieldName = &quot;file name&quot;;
            fieldVal = fn;
            &lt;bc:red&gt;query = new BasicDBObject(&quot;filename&quot;, fn);&lt;/bc&gt;
        }

        DBCursor cursor = collection.find(query, fieldSelect);
        int found = cursor.size();
        if(found == 0) {
            status = &quot;No files found with &quot; + fieldName + &quot; &apos;&quot; + fieldVal + &quot;&apos;.&quot;;
        } else {
            if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                status = &quot;Delete canceled.&quot;;
            } else {
                GridFS gfs = new GridFS(db0, col);
                for(DBObject obj : cursor) {
                    gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                }
                status = &quot;Deleted &quot; + found + &quot; file&quot; + StringUtil.s(found) + &quot;.&quot;;
            }
        }

        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Even more clean up</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;

        // Set query components
        String fieldId;
        String fieldName;
        Object fieldVal;
        if(id0 != null) {
            &lt;bc:blue&gt;fieldId   = &quot;_id&quot;;&lt;/bc&gt;
            fieldName = &quot;ID&quot;;
            fieldVal  = id0;
        } else {
            &lt;bc:blue&gt;fieldId   = &quot;filename&quot;;&lt;/bc&gt;
            fieldName = &quot;file name&quot;;
            fieldVal  = fn;
        }

        &lt;bc:blue&gt;// Create query
        BasicDBObject query = new BasicDBObject(fieldId, fieldVal);
        BasicDBObject fieldSelect = new BasicDBObject();&lt;/bc&gt;

        // Execute query
        DBCursor cursor = collection.find(query, fieldSelect);
        int found = cursor.size();
        if(found == 0) {
            status = &quot;No files found with &quot; + fieldName + &quot; &apos;&quot; + fieldVal + &quot;&apos;.&quot;;
        } else {
            if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                status = &quot;Delete canceled.&quot;;
            } else {
                GridFS gfs = new GridFS(db0, col);
                for(DBObject obj : cursor) {
                    gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                }
                status = &quot;Deleted &quot; + found + &quot; file&quot; + StringUtil.s(found) + &quot;.&quot;;
            }
        }

        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Same code for ID or File Name query</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;

        // Set query components
        String fieldId;
        String fieldName;
        Object fieldVal;
        if(id0 != null) {
            fieldId   = &quot;_id&quot;;
            fieldName = &quot;ID&quot;;
            fieldVal  = id0;
        } else {
            fieldId   = &quot;filename&quot;;
            fieldName = &quot;file name&quot;;
            fieldVal  = fn;
        }

        // Create query
        BasicDBObject query = new BasicDBObject(fieldId, fieldVal);
        BasicDBObject fieldSelect = new BasicDBObject();

        // Execute query
        DBCursor cursor = collection.find(query, fieldSelect);
        int found = cursor.size();
        if(found == 0) {
            status = &quot;No files found with &quot; + fieldName + &quot; &apos;&quot; + fieldVal + &quot;&apos;.&quot;;
        } else {
            if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {    &lt;bc:blue&gt;// found = [0|1] for id0 != null&lt;/bc&gt;
                status = &quot;Delete canceled.&quot;;
            } else {
                GridFS gfs = new GridFS(db0, col);
                for(DBObject obj : cursor) {                &lt;bc:blue&gt;// Iterate over all results regardless of if there&apos;s only 1&lt;/bc&gt;
                    gfs.remove((ObjectId) obj.get(&quot;_id&quot;));  &lt;bc:blue&gt;// Fetch ID from file, even if we already know ID from id0 param&lt;/bc&gt;
                }
                status = &quot;Deleted &quot; + found + &quot; file&quot; + StringUtil.s(found) + &quot;.&quot;;
            }
        }

        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>New organization leads to new opportunities</msg>
            <src>
    private static void deleteAction(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;

        // Set query components
        String fieldId;
        String fieldName;
        Object fieldVal;
        if(id0 != null) {
            fieldId   = &quot;_id&quot;;
            fieldName = &quot;ID&quot;;
            fieldVal  = id0;
        } else {
            fieldId   = &quot;filename&quot;;
            fieldName = &quot;file name&quot;;
            fieldVal  = fn;
        }

        // Create query
        BasicDBObject query = new BasicDBObject(fieldId, fieldVal);
        BasicDBObject fieldSelect = new BasicDBObject();

        // Execute query
        DBCursor cursor = collection.find(query, fieldSelect);
        int found = cursor.size();
        if(found == 0) {
            status = &quot;No files found with &quot; + fieldName + &quot; &apos;&quot; + fieldVal + &quot;&apos;.&quot;;
        } else {
            if(!force &amp;&amp; !confirm(&quot;Delete &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                status = &quot;Delete canceled.&quot;;
            } else {
                GridFS gfs = new GridFS(db0, col);
                for(DBObject obj : cursor) {
                    gfs.remove((ObjectId) obj.get(&quot;_id&quot;));
                }
                status = &quot;Deleted &quot; + found + &quot; file&quot; + StringUtil.s(found) + &quot;.&quot;;
            }
        }

        System.out.println(&quot;Delete: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Only mentions of &apos;Delete&apos;</msg>
            <src>
    private static void &lt;bc:red&gt;delete&lt;/bc&gt;Action(DB db0, String col, ObjectId id0, String fn, boolean force) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;

        // Set query components
        String fieldId;
        String fieldName;
        Object fieldVal;
        if(id0 != null) {
            fieldId   = &quot;_id&quot;;
            fieldName = &quot;ID&quot;;
            fieldVal  = id0;
        } else {
            fieldId   = &quot;filename&quot;;
            fieldName = &quot;file name&quot;;
            fieldVal  = fn;
        }

        // Create query
        BasicDBObject query = new BasicDBObject(fieldId, fieldVal);
        BasicDBObject fieldSelect = new BasicDBObject();

        // Execute query
        DBCursor cursor = collection.find(query, fieldSelect);
        int found = cursor.size();
        if(found == 0) {
            status = &quot;No files found with &quot; + fieldName + &quot; &apos;&quot; + fieldVal + &quot;&apos;.&quot;;
        } else {
            if(!force &amp;&amp; !confirm(&quot;&lt;bc:red&gt;Delete&lt;/bc&gt; &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                status = &quot;&lt;bc:red&gt;Delete&lt;/bc&gt; canceled.&quot;;
            } else {
                GridFS gfs = new GridFS(db0, col);
                for(DBObject obj : cursor) {
                    &lt;bc:red&gt;gfs.remove((ObjectId) obj.get(&quot;_id&quot;));&lt;/bc&gt;
                }
                status = &quot;&lt;bc:red&gt;Deleted&lt;/bc&gt; &quot; + found + &quot; file&quot; + StringUtil.s(found) + &quot;.&quot;;
            }
        }

        System.out.println(&quot;&lt;bc:red&gt;Delete&lt;/bc&gt;: &quot; + status);
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    private static void &lt;bc:blue&gt;any&lt;/bc&gt;Action(&lt;bc:blue&gt;String actionName&lt;/bc&gt;, DB db0, String col, ObjectId id0, String fn, boolean force&lt;bc:blue&gt;, FileAction action&lt;/bc&gt;) {
        DBCollection collection = db0.getCollection(col + &quot;.files&quot;);
        String status;

        // Set query components
        String fieldId;
        String fieldName;
        Object fieldVal;
        if(id0 != null) {
            fieldId   = &quot;_id&quot;;
            fieldName = &quot;ID&quot;;
            fieldVal  = id0;
        } else {
            fieldId   = &quot;filename&quot;;
            fieldName = &quot;file name&quot;;
            fieldVal  = fn;
        }

        // Create query
        BasicDBObject query = new BasicDBObject(fieldId, fieldVal);
        BasicDBObject fieldSelect = new BasicDBObject();

        // Execute query
        DBCursor cursor = collection.find(query, fieldSelect);
        int found = cursor.size();
        if(found == 0) {
            status = &quot;No files found with &quot; + fieldName + &quot; &apos;&quot; + fieldVal + &quot;&apos;.&quot;;
        } else {
            if(!force &amp;&amp; !confirm(&lt;bc:blue&gt;&quot;[&quot; + actionName + &quot;]: Continue with &quot; + found + &quot; file&quot; + StringUtil.s(found))) {
                status = &quot;&lt;bc:blue&gt;Canceled.&lt;/bc&gt;&quot;;
            } else {
                GridFS gfs = new GridFS(db0, col);
                for(DBObject obj : cursor) {
                    &lt;bc:blue&gt;action.perform(gfs, obj)&lt;/bc&gt;
                }
                status = &quot;&lt;bc:blue&gt;Processed&lt;/bc&gt; &quot; + found + &quot; file&quot; + StringUtil.s(found) + &quot;.&quot;;
            }
        }

        System.out.println(&lt;bc:blue&gt;&quot;[&quot; + actionName + &quot;]: &quot;&lt;/bc&gt; + status);
    }

    &lt;bc:blue&gt;public interface FileAction {
        void perform(GridFS gfs, DBObject obj);
    }&lt;/bc&gt;
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    
    &lt;bc:blue&gt;Before:

        deleteAction(db0, col, id0, fn, force);    [deleteAction() = 35 lines of code]
        exportAction(db0, col, id0, fn, path0);    [exportAction() = 35 lines of code]
    
        Total = 35 + 35 + 2 = &lt;u&gt;72 lines of code&lt;/ubc&gt;</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Summary</msg>
            <src>    
    
    &lt;bc:red&gt;Before:

        deleteAction(db0, col, id0, fn, force);    [deleteAction() = 35 lines of code]
        exportAction(db0, col, id0, fn, path0);    [exportAction() = 38 lines of code]
    
        Total = 35 + 38 + 2 = &lt;u&gt;75 lines of code&lt;/ubc&gt;


    &lt;bc:blue&gt;After:

        anyAction(&quot;Delete&quot;, db0, col, id0, fn, force, (gfs, obj) -&gt; gfs.remove((ObjectId) obj.get(&quot;_id&quot;)));
        anyAction(&quot;Export&quot;, db0, col, id0, fn, force, (gfs, obj) -&gt; {
            GridFSDBFile file = gfs.find((ObjectId) obj.get(&quot;_id&quot;));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            file.writeTo(out);
            FileUtil.writeBytes(out.toByteArray(), path0);
        });
    
        [anyAction() = 40 lines of code]
        [FileAction = 4 lines of code]
    
        *Total = 40 + 4 + 7 = &lt;u&gt;51 lines of code&lt;/u&gt;  (33% savings with just the 2 methods involved)
    
        Pros: less code, less copy/paste errors, less duplication, more leveraging
        Cons: More complex, more developer training required, time to read/understand code&lt;/bc&gt;</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>?</msg>
            <src>    
    
    &lt;bc:red&gt;Before:

        deleteAction(db0, col, id0, fn, force);    [deleteAction() = 35 lines of code]
        exportAction(db0, col, id0, fn, path0);    [exportAction() = 38 lines of code]
    
        Total = 35 + 38 + 2 = &lt;u&gt;75 lines of code&lt;/ubc&gt;


    &lt;bc:blue&gt;After:

        anyAction(&quot;Delete&quot;, db0, col, id0, fn, force, (gfs, obj) -&gt; gfs.remove((ObjectId) obj.get(&quot;_id&quot;)));
        anyAction(&quot;Export&quot;, db0, col, id0, fn, force, (gfs, obj) -&gt; {
            GridFSDBFile file = gfs.find((ObjectId) obj.get(&quot;_id&quot;));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            file.writeTo(out);
            FileUtil.writeBytes(out.toByteArray(), path0);
        });
    
        [anyAction() = 40 lines of code]
        [FileAction = 4 lines of code]
    
        *Total = 40 + 4 + 7 = &lt;u&gt;51 lines of code&lt;/u&gt;  (33% savings with just the 2 methods involved)
    
        Pros: less code, less copy/paste errors, less duplication, more leveraging
        Cons: More complex, more developer training required, time to read/understand code&lt;/bc&gt;

        My personal preference: 

            Have more complicated but advanced (and capable) code while
            simultaneously locating and developing more capable team 
            members to advance the state of the art together.</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>logger multi-line string</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Just another long debug message</msg>
            <src>
    logger.error(addId(LC_VX) + &quot; i = &quot; + i + &quot;, p = &quot; + pkg.getParentNodeUrl() + &quot;, n = &quot; + 
        node.getUrl() + &quot;, vc = &quot; + node.getVisitCount() + &quot;, v? = &quot; + visit != null);
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Ok, a little better...</msg>
            <src>
    logger.error(
        addId(LC_VX) + 
        &quot; i = &quot; + i + 
        &quot;, p = &quot; + pkg.getParentNodeUrl() + 
        &quot;, n = &quot; + node.getUrl() + 
        &quot;, vc = &quot; + node.getVisitCount() + 
        &quot;, v? = &quot; + visit != null);
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Ok I&apos;m listening...</msg>
            <src>
    logger.error(
        addId(LC_VX) + 
        &quot; i = &quot; + i +
        &quot;, p = &quot; + pkg.getParentNodeUrl() + 
        &quot;, n = &quot; + node.getUrl() + 
        &quot;, vc = &quot; + node.getVisitCount() + 
        &quot;, v? = &quot; + visit != null
    );
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Delimiter change</msg>
            <src>
    logger.error(
        addId(LC_VX) + &lt;bc:blue&gt;&quot; &quot; +&lt;/bc&gt;
        &quot;i = &quot; + i + &lt;bc:blue&gt;&quot;, &quot; +&lt;/bc&gt;
        &quot;p = &quot; + pkg.getParentNodeUrl() + &lt;bc:blue&gt;&quot;, &quot; +    // Sometimes cleaner to place&lt;/bc&gt;
        &quot;n = &quot; + node.getUrl() + &lt;bc:blue&gt;&quot;, &quot; +             // delimiters on the end&lt;/bc&gt;
        &quot;vc = &quot; + node.getVisitCount() + &lt;bc:blue&gt;&quot;, &quot; +&lt;/bc&gt;
        &quot;v? = &quot; + visit != null
    );
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Parentheses</msg>
            <src>
    logger.error(
        addId(LC_VX) + &quot; &quot; +
        &quot;i = &quot; + i + &quot;, &quot; +
        &quot;p = &quot; + pkg.getParentNodeUrl() + &quot;, &quot; +
        &quot;n = &quot; + node.getUrl() + &quot;, &quot; +
        &quot;vc = &quot; + node.getVisitCount() + &quot;, &quot; +
        &quot;v? = &quot; + &lt;bc:blue&gt;(visit != null)                   // Superfluous usage of parentheses OK&lt;/bc&gt;
    );
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>A little alignment</msg>
            <src>
    logger.error(
        addId(LC_VX) + &quot; &quot; +
        &quot;i = &quot;       + i + &quot;, &quot; +
        &quot;p = &quot;       + pkg.getParentNodeUrl() + &quot;, &quot; +
        &quot;n = &quot;       + node.getUrl() + &quot;, &quot; +
        &quot;vc = &quot;      + node.getVisitCount() + &quot;, &quot; +
        &quot;v? = &quot;      + (visit != null)
    );
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>A little alignment</msg>
            <src>
    logger.error(
        addId(LC_VX) + &quot; &quot; +
        &quot;i = &quot;       + i + &quot;, &quot; +
        &quot;p = &quot;       + pkg.getParentNodeUrl() + &quot;, &quot; +
        &quot;n = &quot;       + node.getUrl() + &quot;, &quot; +
        &quot;vc = &quot;      + node.getVisitCount() + &quot;, &quot; +
        &quot;v? = &quot;      + (visit != null)
    );

    &lt;bc:blue&gt;// Looks like a set of KEY-VALUE pairs! :)&lt;/bc&gt;</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>An alternative in other contexts</msg>
            <src>
    logger.error(
        addId(LC_VX) + &quot; &quot; +
        &quot;i = &quot;       + i + &quot;, &quot; +
        &quot;p = &quot;       + pkg.getParentNodeUrl() + &quot;, &quot; +
        &quot;n = &quot;       + node.getUrl() + &quot;, &quot; +
        &quot;vc = &quot;      + node.getVisitCount() + &quot;, &quot; +
        &quot;v? = &quot;      + (visit != null)
    );

    &lt;bc:blue&gt;If you happen to have a map that you need to render as a string...

    Map&lt;String, Object&gt; values = new LinkedHashMap&lt;&gt;();
    values.put(&quot;i&quot;,  i);
    values.put(&quot;p&quot;,  pkg.getParentNodeUrl());
    values.put(&quot;n&quot;,  node.getUrl());
    values.put(&quot;vc&quot;, node.getVisitCount());
    values.put(&quot;v?&quot;, visit != null);

    String prefix = addId(LC_VX) + &quot; &quot;;
    logger.error(StringUtil.join(&lt;u&gt;values&lt;/u&gt;, &lt;u&gt;&quot; = &quot;&lt;/u&gt;, &lt;u&gt;&quot;, &quot;&lt;/u&gt;, &lt;u&gt;prefix&lt;/u&gt;, &lt;u&gt;null&lt;/u&gt;))&lt;/bc&gt;
                                  map    kvsep  pairsep  pre  suffix</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Validator</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Looks good to me!</msg>
            <src>
    Validator validator = new Validator() {
        public boolean accept(ValidatingTextField txt, String text) {
            text = text.trim();
            return
                NumUtil.isInt(text) &amp;&amp;
                NumUtil.i(text) &gt;= 0
            ;
        }
    };

    JPanel pnlMaxEntities = Lay.FL(&quot;L&quot;,
        Lay.lb(&quot;Max Entities: &quot;, &quot;eb=5r&quot;),
        txtMaxEntities = Lay.tx(&quot;&quot;, 5, validator, &quot;validating,selectall,center,prefh=25&quot;),
        &quot;nogap,eb=10tl&quot;
    );
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Sharing is caring</msg>
            <src>
    &lt;bc:blue&gt;Validator validator = new NonnegativeIntContextValidator();&lt;/bc&gt;
    
    JPanel pnlMaxEntities = Lay.FL(&quot;L&quot;,
        Lay.lb(&quot;Max Entities: &quot;, &quot;eb=5r&quot;),
        txtMaxEntities = Lay.tx(&quot;&quot;, 5, validator, &quot;validating,selectall,center,prefh=25&quot;),
        &quot;nogap,eb=10tl&quot;
    );
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Notes Consistency</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>How about these notes?</msg>
            <src>
    Parallel Object Hierarchies Between Params &amp; State
    ==================================================

      These classes are supposed to parallel each other as much as possible:
  
          WebCrawlerJobParams &amp; WebCrawlerJobSummaryState
          GeneralParams &amp; GeneralSummaryState
          DiscoveryParams &amp; DiscoverySummaryState
          DiscoverySourceSubsystemParams &amp; DiscoverySubsystemSummaryState
          SubsystemParams &amp; SubsystemSummaryState
          EvaluationParams/EvaluationSubsystemParams {inverse of} EvaluationSummaryState/EvaluationSubsystemSummaryState
          AccumulationParams &amp; AccumulationSummaryState
          AccumulatorParams &amp; AccumulatorSummaryState
          ...

</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>If it were a snake...</msg>
            <src>
    Parallel Object Hierarchies Between Params &amp; State
    ==================================================

      These classes are supposed to parallel each other as much as possible:
  
          WebCrawlerJobParams &amp; WebCrawlerJobSummaryState
          GeneralParams &amp; GeneralSummaryState
          DiscoveryParams &amp; DiscoverySummaryState
          &lt;bc:red&gt;DiscoverySourceSubsystemParams &amp; DiscoverySubsystemSummaryState&lt;/bc&gt;
          SubsystemParams &amp; SubsystemSummaryState
          EvaluationParams/EvaluationSubsystemParams {inverse of} EvaluationSummaryState/EvaluationSubsystemSummaryState
          AccumulationParams &amp; AccumulationSummaryState
          AccumulatorParams &amp; AccumulatorSummaryState
          ...

</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>OCD to the rescue</msg>
            <src>
    Parallel Object Hierarchies Between Params &amp; State
    ==================================================

      These classes are supposed to parallel each other as much as possible:
  
          WebCrawlerJobParams &amp; WebCrawlerJobSummaryState
          GeneralParams &amp; GeneralSummaryState
          DiscoveryParams &amp; DiscoverySummaryState
          DiscoverySourceSubsystemParams &amp; Discovery&lt;ubc:blue&gt;Source&lt;/ubc&gt;SubsystemSummaryState
          SubsystemParams &amp; SubsystemSummaryState
          EvaluationParams/EvaluationSubsystemParams {inverse of} EvaluationSummaryState/EvaluationSubsystemSummaryState
          AccumulationParams &amp; AccumulationSummaryState
          AccumulatorParams &amp; AccumulatorSummaryState
          ...

    &lt;bc:blue&gt;At this point I had 300 *.java files and was trying to spot 
    errors with the architecture.  Trying to view the source
    in a new dimension, I started on the above list and was 
    able to spot the inconsistency.&lt;/bc&gt;</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Old JAR code</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Some JAR file listing code</msg>
            <src>    
    public class JarUtil {
    
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;String&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();

                if(filter != null) {
                    boolean passesFilter = entry.toString().equals(filter) ||
                        entry.toString().matches(filter);
    
                    if(!passesFilter) {
                        continue;
                    }
                }
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Another old &lt; &gt;</msg>
            <src>    
    public class JarUtil {
    
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&lt;bc:red&gt;String&lt;/bc&gt;&gt;();     &lt;bc:red&gt;// Unnecessary in modern Java&lt;/bc&gt;
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                if(filter != null) {
                    boolean passesFilter = entry.toString().equals(filter) ||
                        entry.toString().matches(filter);
    
                    if(!passesFilter) {
                        continue;
                    }
                }
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>What else?</msg>
            <src>    
    public class JarUtil {
    
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                if(filter != null) {
                    boolean passesFilter = entry.toString().equals(filter) ||
                        entry.toString().matches(filter);
    
                    if(!passesFilter) {
                        continue;
                    }
                }
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Confusion left behind</msg>
            <src>    
    public class JarUtil {
    
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            &lt;bc:red&gt;String filter = &quot;.*\\.class&quot;;&lt;/bc&gt;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                &lt;bc:red&gt;if(filter != null) {&lt;/bc&gt;
                    boolean passesFilter = entry.toString().equals(filter) ||
                        entry.toString().matches(filter);
    
                    if(!passesFilter) {
                        continue;
                    }
                &lt;bc:red&gt;}&lt;/bc&gt;
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        &lt;bc:red&gt;// Ask yourself: SHOULD this method take an optional &quot;filter&quot; 
        // parameter?  Obviously someone was thinking about it...&lt;/bc&gt;
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            &lt;bc:red&gt;String filter = &quot;.*\\.class&quot;;&lt;/bc&gt;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                &lt;bc:red&gt;if(filter != null) {&lt;/bc&gt;
                    boolean passesFilter = entry.toString().equals(filter) ||
                        entry.toString().matches(filter);
    
                    if(!passesFilter) {
                        continue;
                    }
                &lt;bc:red&gt;}&lt;/bc&gt;
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        &lt;bc:red&gt;// Ask yourself: SHOULD this method take an optional &quot;filter&quot; 
        // parameter?  Obviously someone was thinking about it...
        // Choice: Not at this time, but leave comment. Plus, the method is
        // NAMED listJar&lt;u&gt;Classes&lt;/u&gt;, so it&apos;s not expected to be so flexible.&lt;/bc&gt;
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            &lt;bc:red&gt;String filter = &quot;.*\\.class&quot;;&lt;/bc&gt;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                &lt;bc:red&gt;if(filter != null) {&lt;/bc&gt;
                    boolean passesFilter = entry.toString().equals(filter) ||
                        entry.toString().matches(filter);
    
                    if(!passesFilter) {
                        continue;
                    }
                &lt;bc:red&gt;}&lt;/bc&gt;
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        &lt;bc:blue&gt;// TODO: Could augment scope of method with developer-provided filters&lt;/bc&gt;
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                &lt;bc:blue&gt;boolean passesFilter = entry.toString().equals(filter) ||
                    entry.toString().matches(filter);
    
                if(!passesFilter) {
                    continue;
                }&lt;/bc&gt;
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                boolean passesFilter = &lt;bc:red&gt;entry.toString().equals(filter)&lt;/bc&gt; ||   &lt;bc:red&gt;// Ridiculous&lt;/bc&gt;
                    entry.toString().matches(filter);
    
                if(!passesFilter) {
                    continue;
                }
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
    
                &lt;bc:blue&gt;boolean passesFilter = entry.toString().matches(filter);&lt;/bc&gt;
    
                if(!passesFilter) {
                    continue;
                }
    
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
    
            return extractedClasses.toArray(new String[0]);
        }

    }</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                &lt;bc:blue&gt;if(!entry.toString().matches(filter)) {
                    continue;
                }&lt;/bc&gt;
                String str = entry.toString();
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                if(!&lt;bc:red&gt;entry.toString()&lt;/bc&gt;.matches(filter)) {
                    continue;
                }
                String str = &lt;bc:red&gt;entry.toString()&lt;/bc&gt;;
                if(!str.contains(&quot;$&quot;)) {
                    str = str.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    str = str.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(str);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                &lt;bc:blue&gt;String path = entry.toString();&lt;/bc&gt;
                if(!&lt;bc:blue&gt;path&lt;/bc&gt;.matches(filter)) {
                    continue;
                }
                if(!&lt;bc:blue&gt;path&lt;/bc&gt;.contains(&quot;$&quot;)) {
                    &lt;bc:blue&gt;path&lt;/bc&gt; = &lt;bc:blue&gt;path&lt;/bc&gt;.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    &lt;bc:blue&gt;path&lt;/bc&gt; = &lt;bc:blue&gt;path&lt;/bc&gt;.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(&lt;bc:blue&gt;path&lt;/bc&gt;);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String path = entry.toString();
                &lt;bc:red&gt;if(!path.matches(filter)) {            // Two branching styles to&lt;/bc&gt;
                    continue;                          &lt;bc:red&gt;// do the same thing.&lt;/bc&gt;
                }
                &lt;bc:red&gt;if(!path.contains(&quot;$&quot;)) {&lt;/bc&gt;
                    path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(path);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String path = entry.toString();
                if(&lt;bc:blue&gt;path.matches(filter) &amp;&amp; !path.contains(&quot;$&quot;)&lt;/bc&gt;) {
                    path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(path);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &quot;.*\\.class&quot;;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String path = entry.toString();
                if(path.matches(filter) &lt;bc:red&gt;&amp;&amp; !path.contains(&quot;$&quot;)&lt;/bc&gt;) {  &lt;bc:red&gt;// Just more formatting constraints...&lt;/bc&gt;
                    path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(path);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            String filter = &lt;bc:blue&gt;&quot;[^\\$]*\\.class&quot;&lt;/bc&gt;;               &lt;bc:blue&gt;// Just have a comprehensive pattern&lt;/bc&gt;
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String path = entry.toString();
                if(&lt;bc:blue&gt;path.matches(filter)&lt;/bc&gt;) {
                    path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(path);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            &lt;bc:blue&gt;String filter = &quot;[^\\$]*\\.class&quot;;       // Moved up due to it being more of a &quot;constant&quot; for the method&lt;/bc&gt;
            JarFile jar = new JarFile(jarFile);
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String path = entry.toString();
                if(path.matches(filter)) {
                    path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(path);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            String filter = &quot;[^\\$]*\\.class&quot;;
            &lt;bc:red&gt;JarFile jar = new JarFile(jarFile);             // javac warning: Resource leak: &apos;jar&apos; is never closed&lt;/bc&gt;
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String path = entry.toString();
                if(path.matches(filter)) {
                    path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(path);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            String filter = &quot;[^\\$]*\\.class&quot;;
            &lt;bc:red&gt;JarFile jar = new JarFile(jarFile);             // You must close I/O streams &amp; resources&lt;/bc&gt;
            Enumeration&lt;JarEntry&gt; entries = jar.entries();
            Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
            while(entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String path = entry.toString();
                if(path.matches(filter)) {
                    path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                    path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                    extractedClasses.add(path);
                }    
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) throws IOException {
            String filter = &quot;[^\\$]*\\.class&quot;;
            &lt;bc:blue&gt;try(JarFile jar = new JarFile(jarFile)) {             // Yay for try-resource blocks!&lt;/bc&gt;
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
            &lt;bc:blue&gt;}&lt;/bc&gt;        &lt;bc:blue&gt;// AutoClosable will be closed here, regardless of exception&lt;/bc&gt;
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) &lt;bc:red&gt;throws IOException&lt;/bc&gt; {
            String filter = &quot;[^\\$]*\\.class&quot;;              &lt;bc:red&gt;// ^ Annoying for a &quot;convenient&quot; utility class&lt;/bc&gt;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
            }
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
            &lt;bc:blue&gt;} catch(Exception e) {
                throw new HidingRuntimeException(e);    // Explicitly named exception class
            }&lt;/bc&gt;
            return extractedClasses.toArray(new String[0]);
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                &lt;bc:red&gt;Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();&lt;/bc&gt;
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
            } catch(Exception e) {
                throw new HidingRuntimeException(e);
            }
            &lt;bc:red&gt;return extractedClasses.toArray(new String[0]);         // Compile error!&lt;/bc&gt;
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                &lt;bc:blue&gt;Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();&lt;/bc&gt;
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
                &lt;bc:blue&gt;return extractedClasses.toArray(new String[0]);&lt;/bc&gt;
            } catch(Exception e) {
                throw new HidingRuntimeException(e);
            }
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                &lt;bc:007F0E&gt;Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();                        // Happy Path
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
                return extractedClasses.toArray(new String[0]);&lt;/bc&gt;
            } catch(Exception e) {
                &lt;bc:red&gt;throw new HidingRuntimeException(e);                       // Sad Path&lt;/bc&gt;
            }
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                &lt;bc:007F0E&gt;Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new HashSet&lt;&gt;();
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();                        // Happy Path
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
                return extractedClasses.toArray(new String[0]);&lt;/bc&gt;
            } catch(Exception e) {
                &lt;bc:red&gt;throw new HidingRuntimeException(e);                       // Sad Path&lt;/bc&gt;
            }
        }        &lt;bc:blue&gt;// Here I violate my personal rule that all&lt;/bc&gt;
                 &lt;bc:blue&gt;// non-void methods should end in &apos;return&apos;&lt;/bc&gt;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new &lt;bc:red&gt;HashSet&lt;/bc&gt;&lt;&gt;();   // Think about the usage of this method
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
                return extractedClasses.toArray(new String[0]);
            } catch(Exception e) {
                throw new HidingRuntimeException(e);
            }
        }

    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Beautiful code grows on trees</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] listJarClasses(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new &lt;bc:blue&gt;TreeSet&lt;/bc&gt;&lt;&gt;();   &lt;bc:blue&gt;// Think about the usage of this method&lt;/bc&gt;
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
                return extractedClasses.toArray(new String[0]);
            } catch(Exception e) {
                throw new HidingRuntimeException(e);
            }
        }

    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Too much context!</msg>
            <src>    
    public class JarUtil {
    
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] &lt;bc:red&gt;listJarClasses&lt;/bc&gt;(File jarFile) {           &lt;bc:red&gt;// There&apos;s no String.stringLength(), URL.getUrlHost()...&lt;/bc&gt;
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new TreeSet&lt;&gt;();
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }    
                }
                return extractedClasses.toArray(new String[0]);
            } catch(Exception e) {
                throw new HidingRuntimeException(e);
            }
        }

    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Much, much cleaner</msg>
            <src>       
    public class JarUtil {
        
        // TODO: Could augment scope of method with developer-provided filters
        public static String[] &lt;bc:blue&gt;listClasses&lt;/bc&gt;(File jarFile) {
            String filter = &quot;[^\\$]*\\.class&quot;;
            try(JarFile jar = new JarFile(jarFile)) {
                Enumeration&lt;JarEntry&gt; entries = jar.entries();
                Set&lt;String&gt; extractedClasses = new TreeSet&lt;&gt;();
                while(entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String path = entry.toString();
                    if(path.matches(filter)) {
                        path = path.replaceAll(&quot;/&quot;, &quot;.&quot;);
                        path = path.replaceAll(&quot;\\.class$&quot;, &quot;&quot;);
                        extractedClasses.add(path);
                    }
                }
                return extractedClasses.toArray(new String[0]);
            } catch(Exception e) {
                throw new HidingRuntimeException(e);
            }
        }
    
    }
    </src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Bash init.d Script</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Reorg and style clean up</msg>
            <src>
    function start() {
        CONF=&quot;$AVONDALE_DIR/service/conf/server-args.conf&quot;
        OUT=&quot;$AVONDALE_DIR/service/avondale.out&quot;              &lt;bc:blue&gt;# Add some new functionality.&lt;/bc&gt;
        OUTP=&quot;$AVONDALE_DIR/service/avondale.out.prev&quot;        &lt;bc:blue&gt;# Move these 4 files to a&lt;/bc&gt;
        ERR=&quot;$AVONDALE_DIR/service/avondale.err&quot;              &lt;bc:blue&gt;# &apos;logs&apos; subdirectory.&lt;/bc&gt;
        ERRP=&quot;$AVONDALE_DIR/service/avondale.err.prev&quot;        &lt;bc:blue&gt;# (this was an init.d script)&lt;/bc&gt;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>That was easy</msg>
            <src>
    function start() {
        CONF=&quot;$AVONDALE_DIR/service/conf/server-args.conf&quot;
        OUT=&quot;$AVONDALE_DIR/service/&lt;bc:blue&gt;logs&lt;/bc&gt;/avondale.out&quot;
        OUTP=&quot;$AVONDALE_DIR/service/&lt;bc:blue&gt;logs&lt;/bc&gt;/avondale.out.prev&quot;    # But let&apos;s clean up...
        ERR=&quot;$AVONDALE_DIR/service/&lt;bc:blue&gt;logs&lt;/bc&gt;/avondale.err&quot;          # Now 4 copies of lot of text 
        ERRP=&quot;$AVONDALE_DIR/service/&lt;bc:blue&gt;logs&lt;/bc&gt;/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Simple</msg>
            <src>
    function start() {
        &lt;bc:blue&gt;LOGS=&quot;$AVONDALE_DIR/service/logs&quot;&lt;/bc&gt;

        CONF=&quot;$AVONDALE_DIR/service/conf/server-args.conf&quot;
        OUT=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.out&quot;
        OUTP=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.out.prev&quot;
        ERR=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.err&quot;
        ERRP=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    function start() {
        &lt;bc:blue&gt;LOGS=&quot;$AVONDALE_DIR/service/logs&quot;&lt;/bc&gt;

        CONF=&quot;&lt;bc:red&gt;$AVONDALE_DIR/service/conf/server-args.conf&lt;/bc&gt;&quot;        :( Lopsided..........
        OUT=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.out&quot;
        OUTP=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.out.prev&quot;
        ERR=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.err&quot;
        ERRP=&quot;&lt;bc:blue&gt;$LOGS&lt;/bc&gt;/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Yay!</msg>
            <src>
    function start() {
        &lt;bc:blue&gt;CONF=&quot;$AVONDALE_DIR/service/conf&quot;&lt;/bc&gt;
        LOGS=&quot;$AVONDALE_DIR/service/logs&quot;

        CONF=&quot;&lt;bc:blue&gt;$CONF&lt;/bc&gt;/server-args.conf&quot;
        OUT=&quot;$LOGS/avondale.out&quot;
        OUTP=&quot;$LOGS/avondale.out.prev&quot;
        ERR=&quot;$LOGS/avondale.err&quot;
        ERRP=&quot;$LOGS/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Semantic collision</msg>
            <src>
    function start() {
        &lt;bc:red&gt;CONF&lt;/bc&gt;=&quot;$AVONDALE_DIR/service/conf&quot;
        LOGS=&quot;$AVONDALE_DIR/service/logs&quot;

        &lt;bc:red&gt;CONF&lt;/bc&gt;=&quot;$CONF/server-args.conf&quot;
        OUT=&quot;$LOGS/avondale.out&quot;
        OUTP=&quot;$LOGS/avondale.out.prev&quot;
        ERR=&quot;$LOGS/avondale.err&quot;
        ERRP=&quot;$LOGS/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>All done!</msg>
            <src>
    function start() {
        &lt;bc:blue&gt;CONF_DIR&lt;/bc&gt;=&quot;$AVONDALE_DIR/service/conf&quot;
        LOGS=&quot;$AVONDALE_DIR/service/logs&quot;

        CONF=&quot;&lt;bc:blue&gt;$CONF_DIR&lt;/bc&gt;/server-args.conf&quot;
        OUT=&quot;$LOGS/avondale.out&quot;
        OUTP=&quot;$LOGS/avondale.out.prev&quot;
        ERR=&quot;$LOGS/avondale.err&quot;
        ERRP=&quot;$LOGS/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>NOT!</msg>
            <src>
    function start() {
        &lt;bc:red&gt;CONF_DIR&lt;/bc&gt;=&quot;$AVONDALE_DIR/service/conf&quot;
        &lt;bc:red&gt;LOGS&lt;/bc&gt;=&quot;$AVONDALE_DIR/service/logs&quot;           &lt;bc:red&gt;# Lazy inconsistency&lt;/bc&gt;

        CONF=&quot;&lt;bc:red&gt;$CONF_DIR&lt;/bc&gt;/server-args.conf&quot;
        OUT=&quot;&lt;bc:red&gt;$LOGS&lt;/bc&gt;/avondale.out&quot;
        OUTP=&quot;&lt;bc:red&gt;$LOGS&lt;/bc&gt;/avondale.out.prev&quot;
        ERR=&quot;&lt;bc:red&gt;$LOGS&lt;/bc&gt;/avondale.err&quot;
        ERRP=&quot;&lt;bc:red&gt;$LOGS&lt;/bc&gt;/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Much better</msg>
            <src>
    function start() {
        CONF_DIR=&quot;$AVONDALE_DIR/service/conf&quot;
        &lt;bc:blue&gt;LOG_DIR&lt;/bc&gt;=&quot;$AVONDALE_DIR/service/logs&quot;

        CONF=&quot;$CONF_DIR/server-args.conf&quot;
        OUT=&quot;&lt;bc:blue&gt;$LOG_DIR&lt;/bc&gt;/avondale.out&quot;
        OUTP=&quot;&lt;bc:blue&gt;$LOG_DIR&lt;/bc&gt;/avondale.out.prev&quot;
        ERR=&quot;&lt;bc:blue&gt;$LOG_DIR&lt;/bc&gt;/avondale.err&quot;
        ERRP=&quot;&lt;bc:blue&gt;$LOG_DIR&lt;/bc&gt;/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Alignment?</msg>
            <src>
    function start() {
        CONF_DIR=&quot;$AVONDALE_DIR/service/conf&quot;
        LOG_DIR=&quot;$AVONDALE_DIR/service/logs&quot;

        CONF=&quot;$CONF_DIR/server-args.conf&quot;
        OUT=&quot;$LOG_DIR/avondale.out&quot;
        OUTP=&quot;$LOG_DIR/avondale.out.prev&quot;
        ERR=&quot;$LOG_DIR/avondale.err&quot;
        ERRP=&quot;$LOG_DIR/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Yes!</msg>
            <src>
    function start() {
        CONF_DIR=&quot;$AVONDALE_DIR/service/conf&quot;
        LOG_DIR=&quot;$AVONDALE_DIR/service/logs&quot;

        &lt;bc:blue&gt;CONF = &quot;$CONF_DIR/server-args.conf&quot;
        OUT  = &quot;$LOG_DIR/avondale.out&quot;
        OUTP = &quot;$LOG_DIR/avondale.out.prev&quot;
        ERR  = &quot;$LOG_DIR/avondale.err&quot;
        ERRP = &quot;$LOG_DIR/avondale.err.prev&quot;
        EXE  = &quot;$AVONDALE_DIR/start-server&quot;&lt;/bc&gt;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Wrong</msg>
            <src>
    function start() {
        CONF_DIR=&quot;$AVONDALE_DIR/service/conf&quot;
        LOG_DIR=&quot;$AVONDALE_DIR/service/logs&quot;

        &lt;bc:red&gt;CONF = &quot;$CONF_DIR/server-args.conf&quot;
        OUT  = &quot;$LOG_DIR/avondale.out&quot;
        OUTP = &quot;$LOG_DIR/avondale.out.prev&quot;
        ERR  = &quot;$LOG_DIR/avondale.err&quot;
        ERRP = &quot;$LOG_DIR/avondale.err.prev&quot;
        EXE  = &quot;$AVONDALE_DIR/start-server&quot;           # Will NOT WORK IN BASH!!&lt;/bc&gt;
        
        if [ -f &quot;$OUT&quot; ]; then
            mv &quot;$OUT&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERR&quot; ]; then
            mv &quot;$ERR&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUT 2&gt; $ERR &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>A little better at least</msg>
            <src>
    function start() {
        CONF_DIR=&quot;$AVONDALE_DIR/service/conf&quot;
        LOG_DIR=&quot;$AVONDALE_DIR/service/logs&quot;

        CONF=&quot;$CONF_DIR/server-args.conf&quot;
        &lt;bc:blue&gt;OUTC&lt;/bc&gt;=&quot;$LOG_DIR/avondale.out&quot;             &lt;bc:blue&gt;# C for &quot;Current&quot;&lt;/bc&gt;
        OUTP=&quot;$LOG_DIR/avondale.out.prev&quot;
        &lt;bc:blue&gt;ERRC&lt;/bc&gt;=&quot;$LOG_DIR/avondale.err&quot;
        ERRP=&quot;$LOG_DIR/avondale.err.prev&quot;
        EXE=&quot;$AVONDALE_DIR/start-server&quot;         &lt;bc:blue&gt;# No need to force it, though&lt;/bc&gt;
        
        if [ -f &quot;&lt;bc:blue&gt;$OUTC&lt;/bc&gt;&quot; ]; then
            mv &quot;&lt;bc:blue&gt;$OUTC&lt;/bc&gt;&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;&lt;bc:blue&gt;$ERRC&lt;/bc&gt;&quot; ]; then
            mv &quot;&lt;bc:blue&gt;$ERRC&lt;/bc&gt;&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; &lt;bc:blue&gt;$OUTC&lt;/bc&gt; 2&gt; &lt;bc:blue&gt;$ERRC&lt;/bc&gt; &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Blank lines help a little</msg>
            <src>
    function start() {
        CONF_DIR=&quot;$AVONDALE_DIR/service/conf&quot;
        LOG_DIR=&quot;$AVONDALE_DIR/service/logs&quot;

        CONF=&quot;$CONF_DIR/server-args.conf&quot;

        OUTC=&quot;$LOG_DIR/avondale.out&quot;
        OUTP=&quot;$LOG_DIR/avondale.out.prev&quot;
        ERRC=&quot;$LOG_DIR/avondale.err&quot;
        ERRP=&quot;$LOG_DIR/avondale.err.prev&quot;

        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUTC&quot; ]; then
            mv &quot;$OUTC&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERRC&quot; ]; then
            mv &quot;$ERRC&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUTC 2&gt; $ERRC &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Finished</msg>
            <src>
    function start() {
        CONF_DIR=&quot;$AVONDALE_DIR/service/conf&quot;
        LOG&lt;bc:red&gt;S&lt;/bc&gt;_DIR=&quot;$AVONDALE_DIR/service/logs&quot;    &lt;bc:red&gt;# Optionally could add S to LOGS&lt;/bc&gt;

        CONF=&quot;$CONF_DIR/server-args.conf&quot;

        OUTC=&quot;$LOG&lt;bc:red&gt;S&lt;/bc&gt;_DIR/avondale.out&quot;
        OUTP=&quot;$LOG&lt;bc:red&gt;S&lt;/bc&gt;_DIR/avondale.out.prev&quot;
        ERRC=&quot;$LOG&lt;bc:red&gt;S&lt;/bc&gt;_DIR/avondale.err&quot;
        ERRP=&quot;$LOG&lt;bc:red&gt;S&lt;/bc&gt;_DIR/avondale.err.prev&quot;

        EXE=&quot;$AVONDALE_DIR/start-server&quot;
        
        if [ -f &quot;$OUTC&quot; ]; then
            mv &quot;$OUTC&quot; &quot;$OUTP&quot;
        fi
        if [ -f &quot;$ERRC&quot; ]; then
            mv &quot;$ERRC&quot; &quot;$ERRP&quot;
        fi
        
        ARGS=`cat $CONF | tr -d &apos;\n&apos; | tr -d &apos;\r&apos;`
        sudo -u dd bash -c &quot;$EXE $ARGS &gt; $OUTC 2&gt; $ERRC &amp;&quot;
        echo &quot;Avondale Service: Started&quot;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>ActionListener Lambda</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Live editing</msg>
            <src>
    btnStart.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            start();
        }
    });

    btnStop.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            stop();
            mnuBar.setEnabled(false);
        }
    });

    JButton btnAdd = Lay.btn(&quot;Add Entry&quot;, 2, new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            addPhrase();
        }
    });

    JButton btnRemove = Lay.btn(&quot;Remove Entry&quot;, 2, new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            tblBlacklist.removeSelected();
            updateLabels();
        }
    });

    JButton btnClear = Lay.btn(&quot;Clear Entries&quot;, 2, new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            mdlSecondaryBlacklist.setEnabledDuplicateSet(EntryLimitType.UNLIMITED);
        }
    });

</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Test Tree Map</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Some old code</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException
    {
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet =
                new HashMap&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt;();
        testSet.put(UrlRuleTree.parseFromString(ruleSet1), createSet1testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2), createSet2testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b), createSet2btestUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet3), createSet3testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring), createSet4testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), createSet5testUrls());

        for (UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            for (String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input)
    {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Low hanging fruit</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException
    &lt;bc:red&gt;{&lt;/bc&gt;
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet =
                new HashMap&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt;();
        testSet.put(UrlRuleTree.parseFromString(ruleSet1), createSet1testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2), createSet2testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b), createSet2btestUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet3), createSet3testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring), createSet4testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), createSet5testUrls());

        &lt;bc:red&gt;for (&lt;/bc&gt;UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            &lt;bc:red&gt;for (&lt;/bc&gt;String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input)
    &lt;bc:red&gt;{&lt;/bc&gt;
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Cleaner, but...</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException &lt;bc:blue&gt;{&lt;/bc&gt;
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet =
                new HashMap&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt;();
        testSet.put(UrlRuleTree.parseFromString(ruleSet1), createSet1testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2), createSet2testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b), createSet2btestUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet3), createSet3testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring), createSet4testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), createSet5testUrls());

        &lt;bc:blue&gt;for(&lt;/bc&gt;UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            &lt;bc:blue&gt;for(&lt;/bc&gt;String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException &lt;bc:blue&gt;{&lt;/bc&gt;
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Unnecessary code nowadays</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException {
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet =
                new HashMap&lt;&lt;bc:red&gt;UrlRuleTree, Map&lt;String, Boolean&gt;&lt;/bc&gt;&gt;();
        testSet.put(UrlRuleTree.parseFromString(ruleSet1), createSet1testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2), createSet2testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b), createSet2btestUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet3), createSet3testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring), createSet4testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), createSet5testUrls());

        for(UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Nice</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException {
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet = &lt;bc:blue&gt;new HashMap&lt;&gt;();&lt;/bc&gt;
        testSet.put(UrlRuleTree.parseFromString(ruleSet1), createSet1testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2), createSet2testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b), createSet2btestUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet3), createSet3testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring), createSet4testUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), createSet5testUrls());

        for(UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Align Divine</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException {
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet = new HashMap&lt;&gt;();
        testSet.put(UrlRuleTree.parseFromString(ruleSet1),            &lt;bc:blue&gt;createSet1testUrls()&lt;/bc&gt;);
        testSet.put(UrlRuleTree.parseFromString(ruleSet2),            &lt;bc:blue&gt;createSet2testUrls()&lt;/bc&gt;);
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b),           &lt;bc:blue&gt;createSet2btestUrls()&lt;/bc&gt;);
        testSet.put(UrlRuleTree.parseFromString(ruleSet3),            &lt;bc:blue&gt;createSet3testUrls()&lt;/bc&gt;);
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring),  &lt;bc:blue&gt;createSet4testUrls()&lt;/bc&gt;);
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), &lt;bc:blue&gt;createSet5testUrls()&lt;/bc&gt;);

        for(UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Those t&apos;s are trying to hide</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException {
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet = new HashMap&lt;&gt;();
        testSet.put(UrlRuleTree.parseFromString(ruleSet1),            createSet1&lt;bc:red&gt;t&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2),            createSet2&lt;bc:red&gt;t&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b),           createSet2b&lt;bc:red&gt;t&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet3),            createSet3&lt;bc:red&gt;t&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring),  createSet4&lt;bc:red&gt;t&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), createSet5&lt;bc:red&gt;t&lt;/bc&gt;estUrls());

        for(UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Proper Camel Case</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException {
        Map&lt;UrlRuleTree, Map&lt;String, Boolean&gt;&gt; testSet = new HashMap&lt;&gt;();
        testSet.put(UrlRuleTree.parseFromString(ruleSet1),            createSet1&lt;bc:blue&gt;T&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2),            createSet2&lt;bc:blue&gt;T&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet2b),           createSet2b&lt;bc:blue&gt;T&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet3),            createSet3&lt;bc:blue&gt;T&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet4ChildOring),  createSet4&lt;bc:blue&gt;T&lt;/bc&gt;estUrls());
        testSet.put(UrlRuleTree.parseFromString(ruleSet5ChildAnding), createSet5&lt;bc:blue&gt;T&lt;/bc&gt;estUrls());

        for(UrlRuleTree tree : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Duplicate code</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException {
        Map&lt;&lt;bc:red&gt;UrlRuleTree&lt;/bc&gt;, Map&lt;String, Boolean&gt;&gt; testSet = new HashMap&lt;&gt;();
        testSet.put(&lt;bc:red&gt;UrlRuleTree.parseFromString(&lt;/bc&gt;ruleSet1&lt;bc:red&gt;)&lt;/bc&gt;,            createSet1TestUrls());
        testSet.put(&lt;bc:red&gt;UrlRuleTree.parseFromString(&lt;/bc&gt;ruleSet2&lt;bc:red&gt;)&lt;/bc&gt;,            createSet2TestUrls());
        testSet.put(&lt;bc:red&gt;UrlRuleTree.parseFromString(&lt;/bc&gt;ruleSet2b&lt;bc:red&gt;)&lt;/bc&gt;,           createSet2bTestUrls());
        testSet.put(&lt;bc:red&gt;UrlRuleTree.parseFromString(&lt;/bc&gt;ruleSet3&lt;bc:red&gt;)&lt;/bc&gt;,            createSet3TestUrls());
        testSet.put(&lt;bc:red&gt;UrlRuleTree.parseFromString(&lt;/bc&gt;ruleSet4ChildOring&lt;bc:red&gt;)&lt;/bc&gt;,  createSet4TestUrls());
        testSet.put(&lt;bc:red&gt;UrlRuleTree.parseFromString(&lt;/bc&gt;ruleSet5ChildAnding&lt;bc:red&gt;)&lt;/bc&gt;, createSet5TestUrls());

        for(&lt;bc:red&gt;UrlRuleTree tree&lt;/bc&gt; : testSet.keySet()) {
            Map&lt;String, Boolean&gt; testUrls = testSet.get(tree);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Much more straightforward</msg>
            <src>
    @Test
    public void testUrls() throws MalformedURLException {
        Map&lt;&lt;bc:blue&gt;String&lt;/bc&gt;, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(&lt;bc:blue&gt;ruleSet1&lt;/bc&gt;,            createSet1TestUrls());
        testSet.put(&lt;bc:blue&gt;ruleSet2&lt;/bc&gt;,            createSet2TestUrls());
        testSet.put(&lt;bc:blue&gt;ruleSet2b&lt;/bc&gt;,           createSet2bTestUrls());
        testSet.put(&lt;bc:blue&gt;ruleSet3&lt;/bc&gt;,            createSet3TestUrls());
        testSet.put(&lt;bc:blue&gt;ruleSet4ChildOring&lt;/bc&gt;,  createSet4TestUrls());
        testSet.put(&lt;bc:blue&gt;ruleSet5ChildAnding&lt;/bc&gt;, createSet5TestUrls());

        for(&lt;bc:blue&gt;String ruleSet&lt;/bc&gt; : testSet.keySet()) {
            &lt;bc:blue&gt;UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);&lt;/bc&gt;
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) throws MalformedURLException {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Malformed Code!</msg>
            <src>
    @Test
    public void testUrls() &lt;bc:red&gt;throws MalformedURLException&lt;/bc&gt; {
        Map&lt;String, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(ruleSet1,            createSet1TestUrls());
        testSet.put(ruleSet2,            createSet2TestUrls());
        testSet.put(ruleSet2b,           createSet2bTestUrls());
        testSet.put(ruleSet3,            createSet3TestUrls());
        testSet.put(ruleSet4ChildOring,  createSet4TestUrls());
        testSet.put(ruleSet5ChildAnding, createSet5TestUrls());

        for(String ruleSet : testSet.keySet()) {
            UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) &lt;bc:red&gt;throws MalformedURLException&lt;/bc&gt; {
        boolean actual = tree.allowed(input);
        if(expected != actual) {                              &lt;bc:red&gt;// Nothing here would imply this exception&lt;/bc&gt;
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);  &lt;bc:red&gt;// Result of a half-implemented task&lt;/bc&gt;
            assertEquals(expected, actual);                   &lt;bc:red&gt;// Whatever code once need it is gone...&lt;/bc&gt;
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Anything else?</msg>
            <src>
    @Test
    public void testUrls() {
        Map&lt;String, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(ruleSet1,            createSet1TestUrls());
        testSet.put(ruleSet2,            createSet2TestUrls());
        testSet.put(ruleSet2b,           createSet2bTestUrls());
        testSet.put(ruleSet3,            createSet3TestUrls());
        testSet.put(ruleSet4ChildOring,  createSet4TestUrls());
        testSet.put(ruleSet5ChildAnding, createSet5TestUrls());

        for(String ruleSet : testSet.keySet()) {
            UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private static void test(UrlRuleTree tree, boolean expected, String input) {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    @Test
    public void testUrls() {
        Map&lt;String, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(ruleSet1,            createSet1TestUrls());
        testSet.put(ruleSet2,            createSet2TestUrls());
        testSet.put(ruleSet2b,           createSet2bTestUrls());
        testSet.put(ruleSet3,            createSet3TestUrls());
        testSet.put(ruleSet4ChildOring,  createSet4TestUrls());
        testSet.put(ruleSet5ChildAnding, createSet5TestUrls());

        for(String ruleSet : testSet.keySet()) {
            UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    &lt;bc:red&gt;// Yes it COMPILES - but completely inappropriate usage of &apos;static&apos;&lt;/bc&gt;
    private &lt;bc:red&gt;static&lt;/bc&gt; void test(UrlRuleTree tree, boolean expected, String input) {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }

    &lt;bc:red&gt;// Methods shouldn&apos;t be static just because they don&apos;t happen to reference any instance variables&lt;/bc&gt;</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    @Test
    public void testUrls() {
        Map&lt;String, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(ruleSet1,            createSet1TestUrls());
        testSet.put(ruleSet2,            createSet2TestUrls());
        testSet.put(ruleSet2b,           createSet2bTestUrls());
        testSet.put(ruleSet3,            createSet3TestUrls());
        testSet.put(ruleSet4ChildOring,  createSet4TestUrls());
        testSet.put(ruleSet5ChildAnding, createSet5TestUrls());

        for(String ruleSet : testSet.keySet()) {
            UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private void test(UrlRuleTree tree, boolean expected, String input) {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>?</msg>
            <src>
    @Test
    public void testUrls() {
        Map&lt;String, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(ruleSet1,            createSet1TestUrls());
        testSet.put(ruleSet2,            createSet2TestUrls());
        testSet.put(ruleSet2b,           createSet2bTestUrls());
        testSet.put(ruleSet3,            createSet3TestUrls());
        testSet.put(ruleSet4ChildOring,  createSet4TestUrls());
        testSet.put(ruleSet5ChildAnding, createSet5TestUrls());

        for(String ruleSet : testSet.keySet()) {
            UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private void test(UrlRuleTree tree, boolean expected, String input) {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            &lt;bc:red&gt;System.out.println(&quot;Failed on [&quot; + input + &quot;]&quot;);     // The whole idea of JUnit is that it reports&lt;/bc&gt;
            assertEquals(expected, actual);                      &lt;bc:red&gt;// test status, so why would we use SOP?&lt;/bc&gt;
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    @Test
    public void testUrls() {
        Map&lt;String, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(ruleSet1,            createSet1TestUrls());
        testSet.put(ruleSet2,            createSet2TestUrls());
        testSet.put(ruleSet2b,           createSet2bTestUrls());
        testSet.put(ruleSet3,            createSet3TestUrls());
        testSet.put(ruleSet4ChildOring,  createSet4TestUrls());
        testSet.put(ruleSet5ChildAnding, createSet5TestUrls());

        for(String ruleSet : testSet.keySet()) {
            UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private void test(UrlRuleTree tree, boolean expected, String input) {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            &lt;bc:blue&gt;String msg = &quot;Failed on [&quot; + input + &quot;]&quot;);&lt;/bc&gt;
            assertEquals(expected, actual);
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Nice</msg>
            <src>
    @Test
    public void testUrls() {
        Map&lt;String, Map&lt;String, Boolean&gt;&gt; testSet = new LinkedHashMap&lt;&gt;();
        testSet.put(ruleSet1,            createSet1TestUrls());
        testSet.put(ruleSet2,            createSet2TestUrls());
        testSet.put(ruleSet2b,           createSet2bTestUrls());
        testSet.put(ruleSet3,            createSet3TestUrls());
        testSet.put(ruleSet4ChildOring,  createSet4TestUrls());
        testSet.put(ruleSet5ChildAnding, createSet5TestUrls());

        for(String ruleSet : testSet.keySet()) {
            UrlRuleTree tree = UrlRuleTree.parseFromString(ruleSet);
            Map&lt;String, Boolean&gt; testUrls = testSet.get(ruleSet);
            for(String url : testUrls.keySet()) {
                test(tree, testUrls.get(url), url);
            }
        }
    }

    private void test(UrlRuleTree tree, boolean expected, String input) {
        boolean actual = tree.allowed(input);
        if(expected != actual) {
            &lt;bc:blue&gt;String msg = &quot;Failed on [&quot; + input + &quot;]&quot;);&lt;/bc&gt;
            assertEquals(&lt;bc:blue&gt;msg,&lt;/bc&gt; expected, actual);           &lt;bc:blue&gt;// JUnit has this feature!&lt;/bc&gt;
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>JUnit does it again</msg>
            <src>NEWPAGE</src>
            <img>junit-msg.png</img>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Mustachio</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Any Thoughts?</msg>
            <src>
    @PreSave
    private void postSave(DBObject object) {
        Map&lt;String, String&gt; newReportParams = new HashMap&lt;&gt;();
        for(String oldKey : reportParams.keySet()) {
            String newKey = oldKey.replace(&quot;$&quot;, &quot;~?~!dollar!~?~&quot;);
            newReportParams.put(newKey, reportParams.get(oldKey));
        }
        object.put(&quot;reportParams&quot;, newReportParams);
    }

    @PreLoad
    private void preLoad(DBObject object) {
        Map&lt;String,String&gt; oldReportParams = (Map&lt;String, String&gt;) object.get(&quot;reportParams&quot;);
        for(String oldKey : oldReportParams.keySet()) {
            String newKey = oldKey.replace(&quot;~?~!dollar!~?~&quot;, &quot;$&quot;);
            reportParams.put(newKey, oldReportParams.get(oldKey));
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Ah, Mustachio in the house!</msg>
            <src>
    @PreSave
    private void postSave(DBObject object) {
        Map&lt;String, String&gt; newReportParams = new HashMap&lt;&gt;();
        for(String oldKey : reportParams.keySet()) {
            String newKey = oldKey.replace(&quot;$&quot;, &lt;bc:blue&gt;&quot;~?~!dollar!~?~&quot;&lt;/bc&gt;);       &lt;bc:blue&gt;// Classic Mustache Pattern - YAY!&lt;/bc&gt;
            newReportParams.put(newKey, reportParams.get(oldKey));
        }
        object.put(&quot;reportParams&quot;, newReportParams);
    }

    @PreLoad
    private void preLoad(DBObject object) {
        Map&lt;String,String&gt; oldReportParams = (Map&lt;String, String&gt;) object.get(&quot;reportParams&quot;);
        for(String oldKey : oldReportParams.keySet()) {
            String newKey = oldKey.replace(&lt;bc:blue&gt;&quot;~?~!dollar!~?~&quot;&lt;/bc&gt;, &quot;$&quot;);       &lt;bc:blue&gt;// Classic Mustache Pattern - YAY!&lt;/bc&gt;
            reportParams.put(newKey, oldReportParams.get(oldKey));
        }
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Bare Minimum Change...</msg>
            <src>
    @PreSave
    private void postSave(DBObject object) {
        Map&lt;String, String&gt; newReportParams = new HashMap&lt;&gt;();
        for(String oldKey : reportParams.keySet()) {
            String newKey = oldKey.replace(&quot;$&quot;, &lt;bc:red&gt;&quot;~?~!dollar!~?~&quot;&lt;/bc&gt;);       &lt;bc:red&gt;// But don&apos;t copy!!  No magic strings!&lt;/bc&gt;
            newReportParams.put(newKey, reportParams.get(oldKey));
        }
        object.put(&quot;reportParams&quot;, newReportParams);
    }

    @PreLoad
    private void preLoad(DBObject object) {
        Map&lt;String,String&gt; oldReportParams = (Map&lt;String, String&gt;) object.get(&quot;reportParams&quot;);
        for(String oldKey : oldReportParams.keySet()) {
            String newKey = oldKey.replace(&lt;bc:red&gt;&quot;~?~!dollar!~?~&quot;&lt;/bc&gt;, &quot;$&quot;);       &lt;bc:red&gt;// But don&apos;t copy!!  No magic strings!&lt;/bc&gt;
            reportParams.put(newKey, oldReportParams.get(oldKey));
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>Ah... I feel safer</msg>
            <src>
    &lt;bc:blue&gt;private static final String SZ_MUSTACHE_SEP = &quot;~?~!dollar!~?~&quot;;      // Single shared variable!&lt;/bc&gt;

    @PreSave
    private void postSave(DBObject object) {
        Map&lt;String, String&gt; newReportParams = new HashMap&lt;&gt;();
        for(String oldKey : reportParams.keySet()) {
            String newKey = oldKey.replace(&quot;$&quot;, &lt;bc:blue&gt;SZ_MUSTACHE_SEP&lt;/bc&gt;);
            newReportParams.put(newKey, reportParams.get(oldKey));
        }
        object.put(&quot;reportParams&quot;, newReportParams);
    }

    @PreLoad
    private void preLoad(DBObject object) {
        Map&lt;String,String&gt; oldReportParams = (Map&lt;String, String&gt;) object.get(&quot;reportParams&quot;);
        for(String oldKey : oldReportParams.keySet()) {
            String newKey = oldKey.replace(&lt;bc:blue&gt;SZ_MUSTACHE_SEP&lt;/bc&gt;, &quot;$&quot;);
            reportParams.put(newKey, oldReportParams.get(oldKey));
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Special characters?</msg>
            <src>
    &lt;bc:blue&gt;private static final String SZ_MUSTACHE_SEP = &quot;~?~!dollar!~?~&quot;;      // Are all characters in this pattern OK?&lt;/bc&gt;

    @PreSave
    private void postSave(DBObject object) {
        Map&lt;String, String&gt; newReportParams = new HashMap&lt;&gt;();
        for(String oldKey : reportParams.keySet()) {
            String newKey = oldKey.replace(&quot;$&quot;, SZ_MUSTACHE_SEP);
            newReportParams.put(newKey, reportParams.get(oldKey));
        }
        object.put(&quot;reportParams&quot;, newReportParams);
    }

    @PreLoad
    private void preLoad(DBObject object) {
        Map&lt;String,String&gt; oldReportParams = (Map&lt;String, String&gt;) object.get(&quot;reportParams&quot;);
        for(String oldKey : oldReportParams.keySet()) {
            String newKey = oldKey.replace(SZ_MUSTACHE_SEP, &quot;$&quot;);
            reportParams.put(newKey, oldReportParams.get(oldKey));
        }
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Float.MIN_VALUE</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Any problems?</msg>
            <src>
   private Object readResolve() {
        if(minXAllowed == 0.0F &amp;&amp; maxXAllowed == 0.0F) {
            minXAllowed = Float.MIN_VALUE;
            maxXAllowed = Float.MAX_VALUE;
        }
        if(minYAllowed == 0.0F &amp;&amp; maxYAllowed == 0.0F) {
            minXAllowed = Float.MIN_VALUE;
            maxYAllowed = Float.MAX_VALUE;
        }
        return this;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>If it were a snake...</msg>
            <src>
   private Object readResolve() {
        if(minXAllowed == 0.0F &amp;&amp; maxXAllowed == 0.0F) {
            minXAllowed = Float.MIN_VALUE;
            maxXAllowed = Float.MAX_VALUE;
        }
        if(minYAllowed == 0.0F &amp;&amp; maxYAllowed == 0.0F) {
            &lt;bc:red&gt;minXAllowed&lt;/bc&gt; = Float.MIN_VALUE;             &lt;bc:red&gt;// Wrong variable!!&lt;/bc&gt;
            maxYAllowed = Float.MAX_VALUE;
        }
        return this;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>Bullet Bug</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Is there a bug?</msg>
            <src>    
    private HNode createNodeFromMatch(StringBuilder sectionText,
                                      RuleSetNodeMatchResult lastMatch,
                                      Range lastMatchTextRange) {

        Rule ruleBullet = lastMatch.getRule(CaptureAs.BULLET);
        boolean noTrimB = ruleBullet != null &amp;&amp; ruleBullet.isNoTrim();
        Rule ruleTitle = lastMatch.getRule(CaptureAs.TITLE);
        boolean noTrimT = ruleTitle != null &amp;&amp; ruleTitle.isNoTrim();
        Rule ruleText = lastMatch.getRule(CaptureAs.TEXT);
        boolean noTrimText = ruleText != null &amp;&amp; ruleText.isNoTrim();

        RuleSetMatchResult result = lastMatch.getResult();
        HNode node = new HNode()
            .setLevelLabel(lastMatch.getNode().getLevelLabel().trim())
            .setChildBulletPattern(lastMatch.getNode().getChildBulletPattern())
            .setSiblingBulletPattern(lastMatch.getNode().getSiblingBulletPattern())
            .setChildPatternReplace(lastMatch.getNode().isChildPatternReplace())
            .setSiblingPatternReplace(lastMatch.getNode().isSiblingPatternReplace())
            .setBullet(specialTrim(result.getBullet(), noTrimT))
            .setTitle(specialTrim(result.getTitle(), noTrimT))
            .setBulletRange(result.getBulletRange())
            .setTitleRange(result.getTitleRange())
            .setTextRange(lastMatchTextRange)
            .setText(specialTrim(sectionText.toString(), noTrimText))
            .setPage(result.getStartPage())
            .setParseExceptionFlags(lastMatch.getParseExceptionFlags());

        return node;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>Is there a bug?</msg>
            <src>    
    private HNode createNodeFromMatch(StringBuilder sectionText,
                                      RuleSetNodeMatchResult lastMatch,
                                      Range lastMatchTextRange) {

        Rule ruleBullet = lastMatch.getRule(CaptureAs.BULLET);
        boolean noTrimB = ruleBullet != null &amp;&amp; ruleBullet.isNoTrim();
        Rule ruleTitle = lastMatch.getRule(CaptureAs.TITLE);
        boolean noTrimT = ruleTitle != null &amp;&amp; ruleTitle.isNoTrim();
        Rule ruleText = lastMatch.getRule(CaptureAs.TEXT);
        boolean noTrimText = ruleText != null &amp;&amp; ruleText.isNoTrim();

        RuleSetMatchResult result = lastMatch.getResult();
        HNode node = new HNode()
            .setLevelLabel(lastMatch.getNode().getLevelLabel().trim())
            .setChildBulletPattern(lastMatch.getNode().getChildBulletPattern())
            .setSiblingBulletPattern(lastMatch.getNode().getSiblingBulletPattern())
            .setChildPatternReplace(lastMatch.getNode().isChildPatternReplace())
            .setSiblingPatternReplace(lastMatch.getNode().isSiblingPatternReplace())
            .setBullet(specialTrim(result.getBullet(), noTrimT))
            .setTitle(specialTrim(result.getTitle(), noTrimT))
            .setBulletRange(result.getBulletRange())
            .setTitleRange(result.getTitleRange())
            .setTextRange(lastMatchTextRange)
            .setText(specialTrim(sectionText.toString(), noTrimText))
            .setPage(result.getStartPage())
            .setParseExceptionFlags(lastMatch.getParseExceptionFlags());

        return node;
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Trim this</msg>
            <src>    
    private HNode createNodeFromMatch(StringBuilder sectionText,
                                      RuleSetNodeMatchResult lastMatch,
                                      Range lastMatchTextRange) {

        Rule ruleBullet = lastMatch.getRule(CaptureAs.BULLET);
        boolean noTrimB = ruleBullet != null &amp;&amp; ruleBullet.isNoTrim();
        Rule ruleTitle = lastMatch.getRule(CaptureAs.TITLE);
        boolean noTrimT = ruleTitle != null &amp;&amp; ruleTitle.isNoTrim();
        Rule ruleText = lastMatch.getRule(CaptureAs.TEXT);
        boolean noTrimText = ruleText != null &amp;&amp; ruleText.isNoTrim();

        RuleSetMatchResult result = lastMatch.getResult();
        HNode node = new HNode()
            .setLevelLabel(lastMatch.getNode().getLevelLabel().trim())
            .setChildBulletPattern(lastMatch.getNode().getChildBulletPattern())
            .setSiblingBulletPattern(lastMatch.getNode().getSiblingBulletPattern())
            .setChildPatternReplace(lastMatch.getNode().isChildPatternReplace())
            .setSiblingPatternReplace(lastMatch.getNode().isSiblingPatternReplace())
            .setBullet(specialTrim(result.getBullet(), &lt;bc:red&gt;noTrimT&lt;/bc&gt;))         &lt;bc:red&gt;// Should be noTrimB!!&lt;/bc&gt;
            .setTitle(specialTrim(result.getTitle(), noTrimT))
            .setBulletRange(result.getBulletRange())
            .setTitleRange(result.getTitleRange())
            .setTextRange(lastMatchTextRange)
            .setText(specialTrim(sectionText.toString(), noTrimText))
            .setPage(result.getStartPage())
            .setParseExceptionFlags(lastMatch.getParseExceptionFlags());

        return node;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>GOOD</status>
        <title>KeywordsParamsPanel</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Where&apos;s Waldo?</msg>
            <src>
    @Override
    public Class&lt;?&gt;[] getCoordinatedClasses() {
        return new Class[] {
            KeywordsExtractorParams.class,
            KeywordsParamsPanel.class
        };
    }

    @Override
    public KeywordsExtractorParams createParams() {
        return new KeywordsExtractorParams();
    }

    @Override
    public BeanPanel&lt;KeywordsExtractorParams&gt; createParamsPanel(JobParamsWindowContext context) {
        return new KeywordsParamsPanel(context);
    }

    @Override
    public KeywordsExtractor createExtractor(WebCrawlerJob job, KeywordsExtractorParams params) {
        return new KeywordsExtractor(params, job);
    }
</src>
          </Pg>
          <Pg>
            <status>BAD</status>
            <msg>Got you!</msg>
            <src>
    @Override
    public Class&lt;?&gt;[] getCoordinatedClasses() {
        return new Class[] {
            KeywordsExtractorParams.class,
            &lt;bc:red&gt;KeywordsParamsPanel&lt;/bc&gt;.class
        };
    }

    @Override
    public KeywordsExtractorParams createParams() {
        return new KeywordsExtractorParams();
    }

    @Override
    public BeanPanel&lt;KeywordsExtractorParams&gt; createParamsPanel(JobParamsWindowContext context) {
        return new &lt;bc:red&gt;KeywordsParamsPanel&lt;/bc&gt;(context);
    }

    @Override
    public KeywordsExtractor createExtractor(WebCrawlerJob job, KeywordsExtractorParams params) {
        return new KeywordsExtractor(params, job);
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>All is better with the world now</msg>
            <src>
    @Override
    public Class&lt;?&gt;[] getCoordinatedClasses() {
        return new Class[] {
            KeywordsExtractorParams.class,
            Keywords&lt;bc:blue&gt;Extractor&lt;/bc&gt;ParamsPanel.class
        };
    }

    @Override
    public KeywordsExtractorParams createParams() {
        return new KeywordsExtractorParams();
    }

    @Override
    public BeanPanel&lt;KeywordsExtractorParams&gt; createParamsPanel(JobParamsWindowContext context) {
        return new Keywords&lt;bc:blue&gt;Extractor&lt;/bc&gt;ParamsPanel(context);
    }

    @Override
    public KeywordsExtractor createExtractor(WebCrawlerJob job, KeywordsExtractorParams params) {
        return new KeywordsExtractor(params, job);
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>Parse Pattern</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            if(pattern.charAt(index) == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                index += 2;
                HNodePatternToken token;
                switch(pattern.charAt(index)) {
                    case &apos;P&apos;: token = new HNodePatternToken(HNodePatternEnum.PARENT);      break;
                    case &apos;N&apos;: token = new HNodePatternToken(HNodePatternEnum.NUMBER);      break;
                    case &apos;A&apos;: token = new HNodePatternToken(HNodePatternEnum.ALPHA_UPPER); break;
                    case &apos;a&apos;: token = new HNodePatternToken(HNodePatternEnum.ALPHA_LOWER); break;
                    case &apos;R&apos;: token = new HNodePatternToken(HNodePatternEnum.ROMAN_UPPER); break;
                    case &apos;r&apos;: token = new HNodePatternToken(HNodePatternEnum.ROMAN_LOWER); break;
                    default:  token = new HNodePatternToken(HNodePatternEnum.UNKNOWN);     break;
                }
                tokens.add(token);
                index += 2;
            } else {
                StringBuilder literalStringBuilder = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; pattern.charAt(index) != &apos;$&apos;) {
                    literalStringBuilder.append(pattern.charAt(index));
                    index++;
                }
                tokens.add(new HNodePatternToken(HNodePatternEnum.LITERAL, &quot;&quot; + literalStringBuilder.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                index += 2;
                HNodePatternToken token;
                switch(ch) {
                    case &apos;P&apos;: token = new HNodePatternToken(HNodePatternEnum.PARENT);      break;
                    case &apos;N&apos;: token = new HNodePatternToken(HNodePatternEnum.NUMBER);      break;
                    case &apos;A&apos;: token = new HNodePatternToken(HNodePatternEnum.ALPHA_UPPER); break;
                    case &apos;a&apos;: token = new HNodePatternToken(HNodePatternEnum.ALPHA_LOWER); break;
                    case &apos;R&apos;: token = new HNodePatternToken(HNodePatternEnum.ROMAN_UPPER); break;
                    case &apos;r&apos;: token = new HNodePatternToken(HNodePatternEnum.ROMAN_LOWER); break;
                    default:  token = new HNodePatternToken(HNodePatternEnum.UNKNOWN);     break;
                }
                tokens.add(token);
                index += 2;
            } else {
                StringBuilder literalStringBuilder = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literalStringBuilder.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(HNodePatternEnum.LITERAL, &quot;&quot; + literalStringBuilder.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                index += 2;
                HNodePatternEnum patternEnum;
                switch(ch) {
                    case &apos;P&apos;: patternEnum = HNodePatternEnum.PARENT;      break;
                    case &apos;N&apos;: patternEnum = HNodePatternEnum.NUMBER;      break;
                    case &apos;A&apos;: patternEnum = HNodePatternEnum.ALPHA_UPPER; break;
                    case &apos;a&apos;: patternEnum = HNodePatternEnum.ALPHA_LOWER; break;
                    case &apos;R&apos;: patternEnum = HNodePatternEnum.ROMAN_UPPER; break;
                    case &apos;r&apos;: patternEnum = HNodePatternEnum.ROMAN_LOWER; break;
                    default:  patternEnum = HNodePatternEnum.UNKNOWN;     break;
                }
                HNodePatternToken token = new HNodePatternToken(patternEnum);
                tokens.add(token);
                index += 2;
            } else {
                StringBuilder literalStringBuilder = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literalStringBuilder.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(HNodePatternEnum.LITERAL, &quot;&quot; + literalStringBuilder.toString()));
            }
        }
    }</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                index += 2;
                HNodePatternEnum patternEnum;
                switch(ch) {
                    case &apos;P&apos;: patternEnum = HNodePatternEnum.PARENT;      break;
                    case &apos;N&apos;: patternEnum = HNodePatternEnum.NUMBER;      break;
                    case &apos;A&apos;: patternEnum = HNodePatternEnum.ALPHA_UPPER; break;
                    case &apos;a&apos;: patternEnum = HNodePatternEnum.ALPHA_LOWER; break;
                    case &apos;R&apos;: patternEnum = HNodePatternEnum.ROMAN_UPPER; break;
                    case &apos;r&apos;: patternEnum = HNodePatternEnum.ROMAN_LOWER; break;
                    default:  patternEnum = HNodePatternEnum.UNKNOWN;     break;
                }
                HNodePatternToken token = new HNodePatternToken(patternEnum);
                tokens.add(token);
                index += 2;
            } else {
                StringBuilder literalStringBuilder = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literalStringBuilder.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(HNodePatternEnum.LITERAL, &quot;&quot; + literalStringBuilder.toString()));
            }
        }
    }
    
    public enum HNodePatternEnum {
        LITERAL, PARENT, NUMBER, ALPHA_UPPER, ALPHA_LOWER, ROMAN_UPPER, ROMAN_LOWER, UNKNOWN;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                index += 2;
                PatternSegmentType type;
                switch(ch) {
                    case &apos;P&apos;: type = PatternSegmentType.PARENT;      break;
                    case &apos;N&apos;: type = PatternSegmentType.NUMBER;      break;
                    case &apos;A&apos;: type = PatternSegmentType.ALPHA_UPPER; break;
                    case &apos;a&apos;: type = PatternSegmentType.ALPHA_LOWER; break;
                    case &apos;R&apos;: type = PatternSegmentType.ROMAN_UPPER; break;
                    case &apos;r&apos;: type = PatternSegmentType.ROMAN_LOWER; break;
                    default:  type = PatternSegmentType.UNKNOWN;     break;
                }
                HNodePatternToken token = new HNodePatternToken(type);
                tokens.add(token);
                index += 2;
            } else {
                StringBuilder literalStringBuilder = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literalStringBuilder.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, &quot;&quot; + literalStringBuilder.toString()));
            }
        }
    }
    
    public enum PatternSegmentType {
        LITERAL, PARENT, NUMBER, ALPHA_UPPER, ALPHA_LOWER, ROMAN_UPPER, ROMAN_LOWER, UNKNOWN;
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public enum PatternSegmentType {
        LITERAL, 
        PARENT, 
        NUMBER, 
        ALPHA_UPPER, 
        ALPHA_LOWER, 
        ROMAN_UPPER, 
        ROMAN_LOWER, 
        UNKNOWN
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                index += 2;
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                HNodePatternToken token = new HNodePatternToken(type);
                tokens.add(token);
                index += 2;
            } else {
                StringBuilder literalStringBuilder = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literalStringBuilder.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, &quot;&quot; + literalStringBuilder.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                HNodePatternToken token = new HNodePatternToken(type);
                tokens.add(token);
                index += 4;
            } else {
                StringBuilder literalStringBuilder = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literalStringBuilder.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, &quot;&quot; + literalStringBuilder.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                HNodePatternToken token = new HNodePatternToken(type);
                tokens.add(token);
                index += 4;
            } else {
                StringBuilder literal = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literal.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, &quot;&quot; + literal.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                HNodePatternToken token = new HNodePatternToken(type);
                tokens.add(token);
                index += 4;
            } else {
                StringBuilder literal = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literal.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, literal.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                ch = pattern.charAt(index + 2);
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                tokens.add(new HNodePatternToken(type));
                index += 4;
            } else {
                StringBuilder literal = new StringBuilder();
                while (index &lt; pattern.length() &amp;&amp; ch != &apos;$&apos;) {
                    literal.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, literal.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int index = 0;
        while(index &lt; pattern.length()) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= pattern.length()) {
                ch = pattern.charAt(index + 2);
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                tokens.add(new HNodePatternToken(type));
                index += 4;
            } else {
                StringBuilder literal = new StringBuilder();
                while (ch != &apos;$&apos; &amp;&amp; index &lt; pattern.length()) {
                    literal.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, literal.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int len = pattern.length();
        int index = 0;
        while(index &lt; len) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= len) {
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                tokens.add(new HNodePatternToken(type));
                index += 4;
            } else {
                StringBuilder literal = new StringBuilder();
                while (ch != &apos;$&apos; &amp;&amp; index &lt; len) {
                    literal.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, literal.toString()));
            }
        }
    }
</src>
          </Pg>
          <Pg>
            <status>GOOD</status>
            <msg>?</msg>
            <src>
    public HNodeParsedPattern(String pattern) {
        int len = pattern.length();
        int index = 0;
        while(index &lt; len) {
            char ch = pattern.charAt(index);
            if(ch == &apos;$&apos; &amp;&amp; index + 4 &lt;= len) {
                PatternSegmentType type = segmentTypes.get(ch, PatternSegmentType.UNKNOWN);
                tokens.add(new HNodePatternToken(type));
                index += 4;
            } else {
                StringBuilder literal = new StringBuilder();
                while(ch != &apos;$&apos; &amp;&amp; index &lt; len) {
                    literal.append(ch);
                    index++;
                }
                tokens.add(new HNodePatternToken(PatternSegmentType.LITERAL, literal.toString()));
            }
        }
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>Pattern Type Alpha Bug</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    HNodeParsedPattern parsedPattern = new HNodeParsedPattern(pattern);
    StringBuilder newB = new StringBuilder();

    while(parsedPattern.peekNextToken()) {
        HNodePatternToken token = parsedPattern.getNextToken();
        String result;
        switch(token.getPatternType()) {
            case LITERAL:      result = token.getToken(); break;
            case PARENT:       result = bullet; break;
            case NUMBER:       result = &quot;&quot; + (childRuleSetCount+1); break;
            case ALPHA_UPPER:  result = &quot;&quot; + (char) (childRuleSetCount + 64); break;      // Problem
            case ALPHA_LOWER:  result = &quot;&quot; + (char) (childRuleSetCount + 97); break;
            case ROMAN_UPPER:  result = &quot;&quot; + (romanNumerals(childRuleSetCount + 1, true)); break;
            case ROMAN_LOWER:  result = &quot;&quot; + (romanNumerals(childRuleSetCount + 1, false)); break;
            default:           result = &quot;&lt;UNKNOWN FAILURE!&gt;&quot;; break;
        }
        newB.append(result);
    }
    </src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>Table Selection Model</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>Nice Right?</msg>
            <src>
    boolean success = ((ReportEntrySummaryTableModel)tblUrls.getModel()).moveReportEntry(tblUrls.getSelectionModel().getMinSelectionIndex(), tblUrls.getSelectionModel().getMaxSelectionIndex(), true);
    if(success) {
        tblUrls.getSelectionModel().setSelectionInterval(tblUrls.getSelectionModel().getMinSelectionIndex()-1, tblUrls.getSelectionModel().getMaxSelectionIndex()-1);
    }
    tblUrls.repaint();
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    ReportEntrySummaryTableModel model = (ReportEntrySummaryTableModel) tblUrls.getModel();
    boolean success = model.moveReportEntry(tblUrls.getSelectionModel().getMinSelectionIndex(), tblUrls.getSelectionModel().getMaxSelectionIndex(), true);
    if(success) {
        tblUrls.getSelectionModel().setSelectionInterval(tblUrls.getSelectionModel().getMinSelectionIndex()-1, tblUrls.getSelectionModel().getMaxSelectionIndex()-1);
    }
    tblUrls.repaint();
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    ReportEntrySummaryTableModel model = (ReportEntrySummaryTableModel) tblUrls.getModel();
    ListSelectionModel selModel = model.getSelectionModel();
    boolean success = model.moveReportEntry(selModel.getMinSelectionIndex(), selModel.getMaxSelectionIndex(), true);
    if(success) {
        tblUrls.getSelectionModel().setSelectionInterval(selModel.getMinSelectionIndex()-1, selModel.getMaxSelectionIndex()-1);
    }
    tblUrls.repaint();
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    ReportEntrySummaryTableModel model = (ReportEntrySummaryTableModel) tblUrls.getModel();
    ListSelectionModel selModel = model.getSelectionModel();
    int min = selModel.getMinSelectionIndex();
    int max = selModel..getMaxSelectionIndex();
    boolean success = model.moveReportEntry(min, max, true);
    if(success) {
        selModel.setSelectionInterval(tblUrls.getSelectionModel().getMinSelectionIndex()-1, tblUrls.getSelectionModel().getMaxSelectionIndex()-1);
    }
    tblUrls.repaint();
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    ReportEntrySummaryTableModel model = (ReportEntrySummaryTableModel) tblUrls.getModel();
    ListSelectionModel selModel = model.getSelectionModel();
    int min = selModel.getMinSelectionIndex();
    int max = selModel.getMaxSelectionIndex();
    boolean success = model.moveReportEntry(min, max, true);
    if(success) {
        selModel.setSelectionInterval(min-1, max-1);
    }
    tblUrls.repaint();
</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>NEWPAGE</src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    ReportEntrySummaryTableModel model = (ReportEntrySummaryTableModel) tblUrls.getModel();
    ListSelectionModel selModel = model.getSelectionModel();
    int min = selModel.getMinSelectionIndex();
    int max = selModel..getMaxSelectionIndex();
    boolean success = model.moveReportEntry(min, max, true);
    if(success) {
        selModel.setSelectionInterval(tblUrls.getSelectionModel().getMinSelectionIndex()-1, tblUrls.getSelectionModel().getMaxSelectionIndex()-1);
    }
    tblUrls.repaint();
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>HttpOptions Fields</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class HttpOptions implements Serializable {
    
    
        ////////////
        // FIELDS //
        ////////////
    
        // Defaults
    
        public static final HttpRequestOptions  DEFAULT_DOWNLOAD_REQUEST_OPTIONS = new HttpRequestOptions();
        public static final HttpRequestOptions  DEFAULT_ROBOTS_REQUEST_OPTIONS   = createDefaultRobotsOptions();
        public static final boolean             DEFAULT_RECORD_HEADER_STATS      = false;
        public static final Map&lt;String, String&gt; DEFAULT_HEADER_COLLAPSE_PATTERNS = Http.DEFAULT_HEADER_COLLAPSE_PATTERNS;
    
        // Core
    
        private HttpRequestOptions  downloadRequestOptions = DEFAULT_DOWNLOAD_REQUEST_OPTIONS;
        private HttpRequestOptions  robotsRequestOptions   = DEFAULT_ROBOTS_REQUEST_OPTIONS;
        private boolean             recordHeaderStats      = DEFAULT_RECORD_HEADER_STATS;
        private Map&lt;String, String&gt; headerCollapsePatterns = DEFAULT_HEADER_COLLAPSE_PATTERNS;

        ...
    </src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>ACRONYMS</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    // Acronyms //
    decode_pdf = new PdfDecoderFX();
    thumbnails = new JavaFXThumbnailPanel(decode_pdf);
    currentGUI = new JavaFxGUI(stage, decode_pdf, commonValues, thumbnails, properties);
    decode_pdf.addExternalHandler(new JavaFXDefaultActionHandler(currentGUI), Options.FormsActionHandler);
    decode_pdf.addExternalHandler(new FXClientExternalHandler(), Options.AdditionalHandler);
    
    HTMLURLGUIInterface
    
    IoException
    UiGenerator
    
    </src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>Send Msg Copy/Paste</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    private void sendUpdateIndicatingMetrics(UpdateIndicatingMetrics update) {
        sendUpdateIndicatingMetrics(update, false);
    }
    private void sendUpdateIndicatingMetrics(final UpdateIndicatingMetrics update, boolean overrideAll) {
        RWorker&lt;Void, Message&gt; worker = new RWorker&lt;Void, Message&gt;() {
            @Override
            protected Message background(Void gathered) throws Exception {
                Message reply = (Message)sendMessage(&quot;changing report entries&quot;, update);
                return reply;
            }
            @Override
            protected void complete() {
                try {
                    Message reply = getResult();
                    if(reply instanceof EvalAnnotationModificationWarning) {
                        Dialogs.showWarning(context.getParentFrameRef(), &quot;An error occurred adding the indicating metric.&quot;, &quot;Update Failed&quot;);
                    }
                    cacheTopUrls();
                    cacheAnnotations();
                } catch(Exception e) {
                    Dialogs.showDetails(
                        context.getParentFrameRef(),
                        &quot;An error occurred updating indicating metric.&quot;, &quot;Update Failed&quot;, e);
                }
            }
        };
        addTaskAndExecute(&quot;Updating Indicating Metrics&quot;, worker);
    }

    public void attemptSendAddLabels(JFrame parent, List&lt;TopUrl&gt; selectedTopUrls, ReportEntryCategory cat) {
        if(!checkLoadStatus()) {
            return;
        }
        if(selectedTopUrls.size() &gt; 1) {
            if(!Dialogs.showConfirm(parent,
                    &quot;Are you sure you want to mark these &quot; +
                    selectedTopUrls.size() + &quot; URLs as &apos;&quot; + cat.getLabel() + &quot;&apos;?&quot;,
                    &quot;Confirm Marking&quot;, true)) {
                return;
            }
        }
        long now = System.currentTimeMillis();
        Map&lt;String, EvalAnnotations&gt; annots = getAnnotations();
        AddLabels msg = new AddLabels();
        for(TopUrl topUrl : selectedTopUrls) {
            EvalAnnotations annot = annots.get(WNode.createNodeId(topUrl.getUrl()));
            Label label = new Label(User.getName(), now, cat.toString());
            Label mostRecent = annot == null ? null : annot.getMostRecentLabel();
            if(mostRecent != null) {
                for(Metric metric : mostRecent.getIndicatingMetrics()) {
                    label.addIndicatingMetric(metric);
                }
            }
            msg.addAddLabel(new AddEvalLabel(
                topUrl.getUrl(),
                topUrl.getEvalIdx(),
                label,
                annot == null ? -1 : annot.getLastModified()
            ));
        }
        sendAddLabels(msg);
    }

    private void sendAddLabels(AddLabels addLabels) {
        sendAddLabels(addLabels, false);
    }
    private void sendAddLabels(final AddLabels addLabels, boolean overrideAll) {
        RWorker&lt;Void, Message&gt; worker = new RWorker&lt;Void, Message&gt;() {
            @Override
            protected Message background(Void gathered) throws Exception {
                Message reply = (Message)sendMessage(&quot;changing report entries&quot;, addLabels);
                return reply;
            }
            @Override
            protected void complete() {
                try {
                    Message reply = getResult();
                    if(reply instanceof EvalAnnotationModificationWarning) {
                        Dialogs.showWarning(context.getParentFrameRef(), &quot;An error occurred adding the label.&quot;, &quot;Update Failed&quot;);
                    }
                    cacheTopUrls();
                    cacheAnnotations();
                } catch(Exception e) {
                    Dialogs.showDetails(
                        context.getParentFrameRef(),
                        &quot;An error occurred adding the label.&quot;, &quot;Update Failed&quot;, e);
                }
            }
        };
        addTaskAndExecute(&quot;Adding Labels&quot;, worker);
    }

    public void attemptSendAddComments(Window parent, List&lt;TopUrl&gt; selectedTopUrls,
             String newReportComment, String newInternalComment) {
        if(!checkLoadStatus()) {
            return;
        }
        if(selectedTopUrls.size() &gt; 1) {
            if(!Dialogs.showConfirm(parent,
                    &quot;Are you sure you want to set the comment(s) for these &quot; +
                    selectedTopUrls.size() + &quot; URLs?&quot;,
                        &quot;Confirm Comments&quot;, true)) {
                return;
            }
        }
        long now = System.currentTimeMillis();
        Map&lt;String, EvalAnnotations&gt; annots = getAnnotations();
        AddComments msg = new AddComments();
        for(TopUrl topUrl : selectedTopUrls) {
            EvalAnnotations annot = annots.get(WNode.createNodeId(topUrl.getUrl()));
            msg.addAddComment(
                new AddEvalComment(
                    topUrl.getUrl(),
                    topUrl.getEvalIdx(),
                    new Comment(
                        CommentTypes.EXTERNAL,
                        User.getName(),
                        now,
                        newReportComment
                    ),
                    annot == null ? -1 : annot.getLastModified()
                )
            );
            msg.addAddComment(
                new AddEvalComment(
                    topUrl.getUrl(),
                    topUrl.getEvalIdx(),
                    new Comment(
                        CommentTypes.INTERNAL,
                        User.getName(),
                        now,
                        newInternalComment
                    ),
                    annot == null ? -1 : annot.getLastModified()
                )
            );
        }
        sendAddComments(msg);
    }

    private void sendAddComments(AddComments addComments) {
        sendAddComments(addComments, false);
    }
    private void sendAddComments(final AddComments addComments, boolean overrideAll) {
        RWorker&lt;Void, Message&gt; worker = new RWorker&lt;Void, Message&gt;() {
            @Override
            protected Message background(Void gathered) throws Exception {
                Message reply = (Message)sendMessage(&quot;changing report entries&quot;, addComments);
                return reply;
            }
            @Override
            protected void complete() {
                try {
                    Message reply = get();
                    if(reply instanceof EvalAnnotationModificationWarning) {
                        Dialogs.showWarning(context.getParentFrameRef(), &quot;An error occurred adding the comment.&quot;, &quot;Update Failed&quot;);
                    }
                    cacheTopUrls();
                    cacheAnnotations();
                } catch(Exception e) {
                    Dialogs.showDetails(
                        context.getParentFrameRef(),
                        &quot;An error occurred adding the comment.&quot;, &quot;Update Failed&quot;, e);
                }
            }
        };
        addTaskAndExecute(&quot;Adding Comments&quot;, worker);
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>URL URL URL</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    
    /////////////
    // UTILITY //
    /////////////

    // Gets the index of a url, respective to its position within its own list.
    // (This also works for duplicate lists grouped under a master url)
    public int getLocalIndexOfUrl(String urlId) {
        for(List&lt;Map&lt;String, List&lt;String&gt;&gt;&gt; categoryUrls : reportOrdering.values()) {
            for(Map&lt;String, List&lt;String&gt;&gt; categoryUrlMap : categoryUrls) {
                for(String keyUrlId : categoryUrlMap.keySet()) {
                    if(urlId.equals(keyUrlId)) {
                        return categoryUrls.indexOf(categoryUrlMap);
                    } else {
                        if(categoryUrlMap.get(keyUrlId).contains(urlId)) {
                            return categoryUrlMap.get(keyUrlId).indexOf(urlId);
                        }
                    }
                }
            }
        }
        return -1;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>(Un)Checked Exceptions</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
    public static File getEnclosingJarFile() {
        Class&lt;?&gt; thisClass = ClassUtil.getCallingClass(1);
        URL url = thisClass.getResource(thisClass.getSimpleName() + &quot;.class&quot;);
        if(url.getProtocol().equals(&quot;jar&quot;)) {
            String jarPath = url.toString();
            int bangIdx = jarPath.indexOf(&apos;!&apos;);
            jarPath = jarPath.substring(4, bangIdx);
            try {
                URL jarURL = new URL(jarPath);
                String file = jarURL.getFile();
                if(jarURL.getHost() != null &amp;&amp; !jarURL.getHost().equals(&quot;&quot;)) {
                    file = &quot;//&quot; + jarURL.getHost() + file;
                }
                try {
                    return new File(URLDecoder.decode(file, &quot;UTF-8&quot;));
                } catch(UnsupportedEncodingException e) {
                    return null;
                }
            } catch(MalformedURLException e) {
                e.printStackTrace();
            }
        }
        return null;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>Semantics</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    Cut / Cleave
    Scream / Screech
    Agnostic / Ignorant
    Evaluation / Analysis
    Download / Downloading</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>String Equals</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>String Equals</msg>
            <src>
    http://stackoverflow.com/questions/5045608/proper-usage-of-java-d-command-line-parameters

    if(asdf == &quot;asdfsadf&quot;) {

    }

    if(&quot;true&quot;.equalsIgnoreCase(asdf)) {

    }</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>ColorUtil/Lib</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class ColorUtil {  // Lib!
        public static final Color LIGHT_YELLOW = Lay.clr(&quot;255,255,190&quot;);
        public static final Color LIGHT_GREEN  = Lay.clr(&quot;205,255,205&quot;);
        public static final Color LIGHT_RED    = Lay.clr(&quot;255,205,205&quot;);
    }
    </src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>GeneralSubsystem clean up</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
   GeneralSummaryState generalSummaryState = new GeneralSummaryState();
    int sIndex = 0;
    for(GeneralSubsystem subsystem : generalSubsystems) {

        // Save rule subsystem for later
        if(subsystem instanceof RuleSubsystem) {
            ruleSubsystem = (RuleSubsystem) subsystem;
            rsIndex = sIndex;
            generalSummaryState.getSubsystemSummaryStates().add(new RuleSubsystemSummaryState());     // Populate later
        } else {
            GeneralSubsystemSummaryState gState = (GeneralSubsystemSummaryState) subsystem.createSummaryState();    // Why cast needed?
            generalSummaryState.getSubsystemSummaryStates().add(gState);
        }

        sIndex++;
    }
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>BAD</status>
        <title>FileGenMgr Method Patterns</title>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class WebCrawlerJob {
    
        ...
    
        public void generateFile(FileGenerationRequest request) {
            fileGenerationManager.addRequestToQueue(request);
        }
    
        public FileGenerationManager getFileGenerationManager() {
            return fileGenerationManager;
        }
    
        public boolean stopFileGeneration(String id) {
            return fileGenerationManager.stop(id);
        }
    }</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>PENDING</status>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    Number Alignment


        addColumn(&quot;#&quot;,                   Long.class,   new int[] { 70,  70,  70});
        addColumn(&quot;ID&quot;,                  String.class, new int[] {200, 200, 200});
        addColumn(&quot;Submitted&quot;,           String.class, new int[] {160, 160, 160});
        addColumn(&quot;Consideration Start&quot;, String.class, new int[] {160, 160, 160});
        addColumn(&quot;Consideration End&quot;,   String.class, new int[] {160, 160, 160});
        addColumn(&quot;Status&quot;,              String.class, new int[] { 70,  70,  70});
        addColumn(&quot;Motive&quot;,              String.class, new int[] { 70,  70,  70});
        addColumn(&quot;Result&quot;,              String.class, new int[] { 70,  70,  70});
        addColumn(&quot;Cleaned URL&quot;,         String.class, new int[] { -1,  -1,  -1});


and

   = 17;
   =  0.2;</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>PENDING</status>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>    
    public class ProjectNameDialog extends EscapeDialog {
    
        ////////////
        // FIELDS //
        ////////////
    
        private String name;
        private RTextField text;
        private RButton btnOk, btnCancel;
    
        public static final int OK = 1;
        public static final int CANCEL = 2;
    
        private int result = CANCEL;
    
        private static String ICON = &quot;copy.gif&quot;;
    
        /////////////////
        // CONSTRUCTOR //
        /////////////////
    
        public ProjectNameDialog(JFrame parent, String label, String defaultName) {
            super(parent, label, true);
            setIcon(ImageLib.get(ICON));
    
            Lay.BLtg(this,
                &quot;C&quot;, text = Lay.tx(defaultName, &quot;prefw=300, maxw=300&quot;),
                &quot;S&quot;, Lay.FL(&quot;R&quot;,
                    btnOk = Lay.btn(&quot;&amp;OK&quot;, ImageLib.get(&quot;accept.gif&quot;)),
                    btnCancel = Lay.btn(&quot;&amp;Cancel&quot;, ImageLib.get(&quot;cancel.gif&quot;))
                ),
                &quot;eb=10,size=[300,120],center&quot;
            );
    
            setDefaultButton(btnOk);
    
            text.addKeyListener(new KeyAdapter() {
                @Override
                public void keyPressed(KeyEvent e) {
                    btnOk.setEnabled(!text.getText().isEmpty());
                }
    
                @Override
                public void keyReleased(KeyEvent e) {
                    btnOk.setEnabled(!text.getText().isEmpty());
                }
            });
    
            btnOk.setEnabled(false);
            btnOk.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    result = OK;
                    name = text.getText();
                    closeDialog();
                }
            });
            btnCancel.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    closeDialog();
                }
            });
        }
    
    
        ///////////////
        // ACCESSORS //
        ///////////////
    
        public int getResult() {
            return result;
        }
    
        @Override
        public String getName() {
            return name;
        }
    }
    </src>
          </Pg>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>NEWPAGE</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>PENDING</status>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>
package gov.sandia.webcomms.http;

...

public class Main {


    ////////////
    // FIELDS //
    ////////////

    private static String[] boolOpts = {&quot;sc&quot;, &quot;srh&quot;, &quot;srd&quot;, &quot;srdrh&quot;, &quot;ss&quot;, &quot;srq&quot;, &quot;cu&quot;, /* non-HttpRequestOptions: */ &quot;pr&quot;, &quot;sv&quot;, &quot;ufp&quot;};
    private static String[] valOpts = {&quot;rs&quot;, &quot;ua&quot;, &quot;pre&quot;, &quot;mcl&quot;, &quot;to&quot;, &quot;px&quot;,            /* non-HttpRequestOptions: */ &quot;m&quot;};

    public static void main(String[] args) {

        ...

        String addlMessage =
            &quot;The command line arguments allow for the creation of &apos;URL Groups&apos;, each with their\n&quot; +
            &quot;distinct options.  A group with system default HTTP request options is conceptually\n&quot; +
            &quot;open at the beginning of the command line and any URLs (either inline or via --urlfile)\n&quot; +
            &quot;provided before --optset or --optchg will have these options.\n&quot; +
            &quot;\nSyntax for OPTIONS used by --optset and --optchg:\n&quot; +
            &quot;  Format: comma-separated list of &apos;[+|-]key|key=value&apos; options, no spaces\n&quot; +
            &quot;  Boolean Options:\n&quot; +
            &quot;      sc    - Save Content (on by default)\n&quot; +
            &quot;      srh   - Save Response Headers(on by default)\n&quot; +
            &quot;      srd   - Save Redirects (on by default)\n&quot; +
            &quot;      srdrh - Save Redirect Response Headers (on by default)\n&quot; +
            &quot;      ss    - Save Security (on by default)\n&quot; +
            &quot;      srq   - Save Request (on by default)\n&quot; +
            &quot;      cu    - Clean URLs (on by default)\n&quot; +
            &quot;      pr    - Print Resources after Fetch (on by default)\n&quot; +
            &quot;      sv    - Save resource content to the save directory\n&quot; +
            &quot;      ufp   - Execute URL fetches in parallel (off by default)\n&quot; +
            &quot;  Valued Options:\n&quot; +
            &quot;      rs    - Redirect Strategy (not used yet)\n&quot; +
            &quot;      ua    - User-Agent\n&quot; +
            &quot;      pre   - Preemptor (not used yet)\n&quot; +
            &quot;      mcl   - Max Content Length (in bytes)\n&quot; +
            &quot;      to    - Timeout (in milliseconds)\n&quot; +
            &quot;      px    - Proxy (host:port format)\n&quot; +
            &quot;      m     - Execute URL fetches in parallel (off by default)\n&quot; +
            &quot;\nSystem Default Options:\n&quot; +
            &quot;  +sc,+srh,+srd,+srdrh,+ss,+srq,+cu,+pr&quot; +
                    &quot;,mcl=&quot; + HttpRequestOptions.DEFAULT_MAX_CONTENT_LENGTH +
                    &quot;,to=&quot; + HttpRequestOptions.DEFAULT_TIMEOUT + &quot;\n&quot; +
            &quot;  In words: save all content, clean URLs, and print results.\n&quot; +

        ...
    }

    ...

    private static String validateAndApplyOptions(String value, ActionGroup curGroup) {
        String kvPat = &quot;([-+]?[:a-z]+)(?:=([:a-z0-9_]+))?&quot;;
        String pattern = kvPat + &quot;(?:,&quot; + kvPat + &quot;)*&quot;;
        if(!StringUtil.matchesIgnoreCase(value, pattern)) {
            return &quot;invalid options format&quot;;
        }
        List&lt;String&gt; boolOptList = Arrays.asList(boolOpts);
        List&lt;String&gt; valOptList = Arrays.asList(valOpts);
        String[] parts = value.split(&quot;,&quot;);
        for(String part : parts) {
            String[] kv = part.split(&quot;=&quot;);
            String k = kv[0].toLowerCase();
            String v = kv.length == 1 ? null : kv[1];
            String del = null;
            if(k.startsWith(&quot;+&quot;) || k.startsWith(&quot;-&quot;)) {
                del = k.substring(0, 1);
                k = k.substring(1);
            }
            if(boolOptList.contains(k)) {

                boolean enabled;
                if(v != null) {
                    if(!v.equalsIgnoreCase(&quot;true&quot;) &amp;&amp; !v.equalsIgnoreCase(&quot;false&quot;)) {
                        return &quot;boolean option &apos;&quot; + kv[0] + &quot;&apos; must only have values &apos;true&apos; or &apos;false&apos; if supplied&quot;;
                    }
                    Boolean b = Boolean.parseBoolean(v);
                    if(del != null) {
                        boolean d = del.equals(&quot;+&quot;);
                        if(b != d) {
                            return &quot;boolean option &apos;&quot; + kv[0] + &quot;&apos; has inconsistent values&quot;;
                        }
                    }
                    enabled = b;
                } else {
                    if(del != null) {
                        enabled = del.equals(&quot;+&quot;);
                    } else {
                        enabled = true;
                    }
                }

//                switch(k) {
//                    case &quot;sc&quot;:    break;  // No validation
//                    case &quot;srh&quot;:   break;  // No validation
//                    case &quot;srd&quot;:   break;  // No validation
//                    case &quot;srdrh&quot;: break;  // No validation
//                    case &quot;ss&quot;:    break;  // No validation
//                    case &quot;srq&quot;:   break;  // No validation
//                    case &quot;cu&quot;:    break;  // No validation
//                    case &quot;pr&quot;:    break;  // No validation
//                    case &quot;ufp&quot;:   break;  // No validation
//                    default:
//                        return &quot;unknown option &apos;&quot; + k + &quot;&apos;&quot;;  // Covered by outer if
//                }

                if(curGroup != null) {
                    HttpRequestOptions options = curGroup.options;
                    switch(k) {
                        case &quot;sc&quot;:    options.setSaveContent(enabled);                 break;
                        case &quot;srh&quot;:   options.setSaveResponseHeaders(enabled);         break;
                        case &quot;srd&quot;:   options.setSaveRedirects(enabled);               break;
                        case &quot;srdrh&quot;: options.setSaveRedirectResponseHeaders(enabled); break;
                        case &quot;ss&quot;:    options.setSaveSecurity(enabled);                break;
                        case &quot;srq&quot;:   options.setSaveRequest(enabled);                 break;
                        case &quot;cu&quot;:    options.setCleanUrls(enabled);                   break;
                        case &quot;pr&quot;:    curGroup.print = enabled;                        break;
                        case &quot;sv&quot;:    curGroup.save = enabled;                         break;
                        case &quot;ufp&quot;:   curGroup.urlsParallel = enabled;                 break;
                    }
                }

            } else if(valOptList.contains(k)) {
                if(del != null) {
                    return &quot;non-boolean option &apos;&quot; + kv[0] + &quot;&apos; can&apos;t have +/-&quot;;
                }
                if(v == null) {
                    return &quot;non-boolean option &apos;&quot; + kv[0] + &quot;&apos; requires value&quot;;
                }

                switch(k) {
//                    case &quot;rs&quot;:  break;  // No validation
//                    case &quot;ua&quot;:  break;  // No validation
//                    case &quot;pre&quot;: break;  // No validation
                    case &quot;mcl&quot;:
                        if(!NumUtil.isLong(v)) {
                            return &quot;max content length must be a long&quot;;
                        }
                        break;
                    case &quot;to&quot;:
                        if(!NumUtil.isInt(v)) {
                            return &quot;timeout must be an integer&quot;;
                        }
                        break;
                    case &quot;px&quot;:
                        int colon = v.indexOf(&apos;:&apos;);
                        if(colon == -1) {
                            return &quot;invalid proxy format&quot;;
                        }
                        String host = v.substring(0, colon);
                        if(host.trim().isEmpty()) {
                            return &quot;invalid proxy host&quot;;
                        }
                        if(!NumUtil.isInt(v.substring(colon + 1))) {
                            return &quot;invalid proxy port&quot;;
                        }
                        break;
                    case &quot;m&quot;:
                        try {
                            RequestMethod.valueOf(v.toUpperCase());
                        } catch(Exception e) {
                            return &quot;method must be one of &quot; + Arrays.toString(RequestMethod.values());
                        }
                        break;
//                    default:
//                        return &quot;unknown option &apos;&quot; + k + &quot;&apos;&quot;;  // Covered by outer if
                }

                if(curGroup != null) {
                    HttpRequestOptions options = curGroup.options;
                    switch(k) {
                        case &quot;rs&quot;:  /*options.setRedirectStrategy(???);*/           break;
                        case &quot;ua&quot;:  options.setOverrideUserAgent(v);                break;
                        case &quot;pre&quot;: /*options.setPreemptor(???);*/                  break;
                        case &quot;mcl&quot;: options.setMaxContentLength(Long.parseLong(v)); break;
                        case &quot;to&quot;:  options.setTimeout(Integer.parseInt(v));        break;
                        case &quot;px&quot;:  options.setProxy(v);                            break;
                        case &quot;m&quot;:   curGroup.setMethod(v.toUpperCase());            break;
                    }
                }

            } else {
                return &quot;invalid option name &apos;&quot; + kv[0] + &quot;&apos;&quot;;
            }
        }
        return null;
    }

    ...
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>PENDING</status>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>        ExtArrayList&lt;Person&gt; list = new ExtArrayList&lt;&gt;();
        list.add(new Person(&quot;joe&quot;));
        list.add(new Person(&quot;mark&quot;));

        File file = User.getDesktop(&quot;list.xml&quot;);
        XStreamWrapper.registerConverter(new ExtArrayListConverter());
        XStreamWrapper.writeToFile(list, file);

        ExtArrayList&lt;?&gt; someList = XStreamWrapper.loadTargetFromFile(file);

        System.out.println(list.equals(someList));


vs.


        ExtArrayList&lt;Person&gt; list = new ExtArrayList&lt;&gt;();
        list.add(new Person(&quot;joe&quot;));
        list.add(new Person(&quot;mark&quot;));

        File file = User.getDesktop(&quot;list.xml&quot;);
        XStreamWrapper.registerConverter(new ExtArrayListConverter());
        XStreamWrapper.writeToFile(list, file);

        ExtArrayList&lt;?&gt; someList = XStreamWrapper.loadTargetFromFile(file);

        System.out.println(someList.equals(list));
</src>
          </Pg>
        </pages>
      </Ex>
      <Ex>
        <status>PENDING</status>
        <pages>
          <Pg>
            <status>PENDING</status>
            <msg>?</msg>
            <src>public class HighlightCounter {
    private Integer total;
    private Integer good;
    private Integer bad;
    private Integer mediumOrUnk;

    public void incrementTotal(int howMuch) {
        if(total == null) {
            total = 0;
        }
        total += howMuch;
    }
}

design example

public class HighlightCounter {
    private Map&lt;String, Integer&gt; counts = new LinkedHashMap&lt;&gt;();
    public void increment(String which, int howMuch) {
        Integer count = counts.get(which);
        if(count == null) {
            count = 0;
        }
        count += howMuch;
        counts.put(which, count);
    }
}
</src>
          </Pg>
        </pages>
      </Ex>
    </examples>
    <curExample>2</curExample>
    <curPage>0</curPage>
  </targetObject>
</replete.xstream.SerializationResult>