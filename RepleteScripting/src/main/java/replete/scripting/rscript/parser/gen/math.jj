/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. math.jj */
/*@egen*/
options
{
    OUTPUT_DIRECTORY = "../gen";
    STATIC = false;
    JAVA_UNICODE_ESCAPE = true;
                 
                   
                                         
                                                                                  
                           
}

PARSER_BEGIN(RScriptParserGenerated)

package replete.scripting.rscript.parser.gen;

import java.lang.reflect.Field;
import java.io.StringReader;

import replete.scripting.rscript.parser.RScript;
import replete.scripting.rscript.parser.values.ConstantValue;
import replete.scripting.rscript.parser.values.ConstantValue.Null;
import replete.scripting.rscript.parser.values.FunctionValue;
import replete.scripting.rscript.parser.values.KeyValuePairValue;
import replete.scripting.rscript.parser.values.ListOrMapValue;
import replete.scripting.rscript.parser.values.OperatorValue;
import replete.scripting.rscript.parser.values.StartValue;
import replete.scripting.rscript.parser.values.UnitValue;
import replete.scripting.rscript.parser.values.VariableValue;

import replete.util.ReflectionUtil;

import javax.measure.unit.*;

/**
 * This parser attempts to be a relatively simple mathematical
 * expression parser.  The parser has support for these constructs:
 *  - numeric literals, integers, longs, floats, doubles, and e notation
 *  - boolean literals (true & false)
 *  - string literals
 *  - variables (identified by an identifier)
 *  - functions (identified by an identifier, (), and any arguments)
 *  - matrices (identified by [] and its elements)
 *  - array/matrix indexing (identified by var[idx(, idx)*])
 *  - mathematical && programming operators:
 *      mathematical: + - * / % (mod) ^ unary minus, unary plus
 *      logical: && || !
 *      equality: == !=
 *      relational: < > <= >=
 *      assignment: = += -= *= /=
 *      grouping: ()
 *  - units (for physics applications)
 * 
 * An identifier is a-zA-Z0-9 and can have _, $, and . in them.  They
 * cannot start with 0-9 nor a period (.).  They cannot end in a period.
 * They can end with any number of tick marks (single quotes, ') to identify
 * derivatives.
 * 
 * Right now the units supported are all those supported by the JScience 
 * library (SI prefixes are supported by JScience as well).  More units
 * can be added if necessary.
 *
 * This parser returns the root node of an abstract syntax tree that represents
 * the expression.
 * 
 * Implicit multiplication is not supported ("x = 3y").  This is due to the 
 * mixing of mathematical- and programming-language-related syntactical
 * concepts.  Namely, variables are supported like a programming language,
 * meaning 'x = yz' could either mean
 *    1) assign the value of the variable yz to x, or
 *    2) assign the value of the expression y * z to x
 * if this rule was not adopted.  Thus, 'x = yz' always implies #1, never #2.
 * Moreover, the expression 'b[2]' could wither mean
 *    1) the element at position 2 in the matrix b, or
 *    2) b multiplied by the matrix expression [2]
 * unless we remove implicit multiplication.
 *
 * Although this parser allows functions to have any name (e.g. "foobar(3, 4)"), 
 * only those functions implemented in the application would allow a parsed
 * expression to be evaluated.  Unknown functions simply provide the tree
 * node for the function with an instance of UnknownFunction, which does not
 * evaluate.
 * 
 * Assignment operators currently require that the left hand side operand be
 * either a variable, a function, or an array access.
 * 
 * The parser is generated by the JTree extension on top of JavaCC which 
 * automatically generates the AST classes for the developer.
 * 
 * Future possibilities:
 *  - left hand side of assignment operator does not need to be lvalue?
 *  - Or, at least disallow cos(3, 4) = <expr> from being a valid expression
 *    for consistency.
 *  - Ternary operator
 */

public class RScriptParserGenerated/*@bgen(jjtree)*/implements RScriptParserGeneratedTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTRScriptParserGeneratedState jjtree = new JJTRScriptParserGeneratedState();

/*@egen*/
    public static RScript parse(String source) throws ParseException {
        if(source == null) {
            throw new IllegalArgumentException("source to parse cannot be null.");
        }
        try {
            return parseInner(source);
        } catch(ParseException e) {
            // This is so any possible ParseException has its message
            // properly appended with the original equation text.
            String newMsg = e.getMessage().trim() + "\nSource: " + source;
            ReflectionUtil.set(e, "detailMessage", newMsg);
            throw e;
        }
    }
    
    // Just used to wrap the inner parsing and TokenMgrError try/catch code for clarity.
    private static RScript parseInner(String source) throws ParseException {
        try {
            StringReader reader = new StringReader(source + "\n");
            RScriptParserGenerated parser = new RScriptParserGenerated(reader);
            ASTStart startNode = parser.Start();
            return new RScript(source, startNode);
        } catch(TokenMgrError err) {
            ParseException p = new ParseException(err.getMessage());
            try {
                Field f = Throwable.class.getDeclaredField("cause");
                f.setAccessible(true);
                f.set(p, err);
            } catch(Exception e) {}
            throw p;
        }
    }

    private String replaceEscape(String inputStr) {
        int len = inputStr.length();
        int p = 0;
        int i;
        String metachars = "tnrbf\\\"'";
        String chars = "\t\n\r\b\f\\\"'";

        StringBuffer output = new StringBuffer();

        while((i = inputStr.indexOf('\\', p)) != -1) {
            output.append(inputStr.substring(p, i));

            if(i + 1 == len)
                break;

            // find metacharacter
            char metac = inputStr.charAt(i + 1);

            // find the index of the metac
            int k = metachars.indexOf(metac);
            if(k == -1) {
                // didn't find the metachar, leave sequence as found.
                // This code should be unreachable if the parser
                // is functioning properly because strings containing
                // unknown escape characters should not be accepted.
                output.append('\\');
                output.append(metac);
            } else {
                // its corresponding true char
                output.append(chars.charAt(k));
            }

            // skip over both escape character & metacharacter
            p = i + 2;
        }

        // add the end of the input string to the output
        if(p < len)
            output.append(inputStr.substring(p));

        return output.toString();
    }

//    int checkMatrixCount(int first, int cur) throws ParseException {
//        if(first == -1) {
//            first = cur;
//        } else if(cur != first) {
//            throw new ParseException("Matrix does not have equal number of columns in each row.");
//        }
//        return first;
//    }
}
PARSER_END(RScriptParserGenerated)

/***************************************************************
SKIP
***************************************************************/

<DEFAULT> SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"

  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>         // Should include EOF, will add \n in input until this is fixed.
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
TOKENS
***************************************************************/

<DEFAULT> TOKEN:
{
    <INTEGER_LITERAL: <DECIMAL_LITERAL>> |
    <#DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])*> |
    <FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
        | "." (["0"-"9"])+ (<EXPONENT>)?
        | (["0"-"9"])+ <EXPONENT>
    > |
    <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+> |
    <STRING_LITERAL:
        "\""
        ( (~["\"","\\","\n","\r"])
        | ("\\" ["n","t","b","r","f","\\","'","\""] )
        )*
        "\""
    >
}

<DEFAULT> TOKEN:
{
    <TRUE_LITERAL:  "true">  |
    <FALSE_LITERAL: "false"> |
    <NULL_LITERAL:  "null">
}

<DEFAULT> TOKEN:
{
    <INDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*(<TICKMARK>)*> |
    <#LETTER: ["A"-"Z", "a"-"z", "_", "$"]> |
    <#DIGIT: ["0"-"9"] > | 
    <#TICKMARK: "'" >
}

<DEFAULT> TOKEN:
{
    < NASSIGN: "="   > |
    < AASSIGN: "+="  > |
    < SASSIGN: "-="  > |
    < MASSIGN: "*="  > |
    < DASSIGN: "/="  > |
    < UASSIGN: "%="  > |
    < PASSIGN: "**=" > |
    
    < COMMA: ","  > |
    < SEMI:  ";"  > |
    < COLON: ":"  > |
    < GT:    ">"  > |
    < LT:    "<"  > |
    < EQ:    "==" > |
    < LE:    "<=" > |
    < GE:    ">=" > |
    < NE:    "!=" > |
    < AND:   "&&" > |
    < OR:    "||" > |
    < PLUS:  "+"  > |
    < MINUS: "-"  > |
    < MUL:   "*"  > |
    < DOT:   "."  > |
    < DIV:   "/"  > |
    < MOD:   "%"  > |
    < NOT:   "!"  > |
    < BNOT:  "~"  > |
    < EXPON: "**" > |
    < LSQ:   "["  > |
    < RSQ:   "]"  > |
    < LRND:  "("  > |
    < RRND:  ")"  >
}

/* Switches to the IN_UNITS lexical state for different parsing of the unit expressions */
<DEFAULT> TOKEN:
{
    < LBRC: "{" > : IN_UNITS
}

/* Switches back to the DEFAULT lexical state for normal parsing */
<IN_UNITS> TOKEN:
{
    < RBRC: "}" > : DEFAULT
}

/* Unit expressions are allowed to be a lot less structured, as the
   parsing will be done by JScience, not this parser. Only those characters
   that could conceivably be present in unit expressions are allowed here. */
<IN_UNITS> TOKEN:
{
    < UNITS: (["A"-"Z", "a"-"z", "_", "0"-"9", "(", ")", "+", "-", "*", "/", "^"])+ >
}


/***************************************************************
GRAMMAR START
***************************************************************/

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*//*@bgen(jjtree) #Statement( 1) */
    {
      ASTStatement jjtn001 = new ASTStatement(JJTSTATEMENT);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
      }
    }
/*@egen*/              
    (
        LOOKAHEAD(2) 
        <SEMI>/*@bgen(jjtree) #Statement( 1) */
               {
                 ASTStatement jjtn002 = new ASTStatement(JJTSTATEMENT);
                 boolean jjtc002 = true;
                 jjtree.openNodeScope(jjtn002);
               }
               try {
/*@egen*/ Statement()/*@bgen(jjtree)*/
               } catch (Throwable jjte002) {
                 if (jjtc002) {
                   jjtree.clearNodeScope(jjtn002);
                   jjtc002 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte002 instanceof RuntimeException) {
                   throw (RuntimeException)jjte002;
                 }
                 if (jjte002 instanceof ParseException) {
                   throw (ParseException)jjte002;
                 }
                 throw (Error)jjte002;
               } finally {
                 if (jjtc002) {
                   jjtree.closeNodeScope(jjtn002,  1);
                 }
               }
/*@egen*/              
    )* 
    [<SEMI>]
    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.jjtSetValue(new StartValue()); 
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement() : {}   /* Can't put #Statement here, or other paths would create Statement nodes */
{
    LOOKAHEAD(LValue() (<NASSIGN>|<AASSIGN>|<SASSIGN>|<MASSIGN>|<DASSIGN>|<UASSIGN>|<PASSIGN>)) 
    AssignExpression()
      |
    RightExpression()
}

void AssignExpression()              : {/*@bgen(jjtree) #Operator( 2) */
  ASTOperator jjtn000 = new ASTOperator(JJTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Operator( 2) */
    try {
/*@egen*/    
    LValue()
    (
        <NASSIGN>  { jjtn000.jjtSetValue(OperatorValue.ASSIGN_NORMAL); }
          |
        <AASSIGN>  { jjtn000.jjtSetValue(OperatorValue.ASSIGN_PLUS); }
          |
        <SASSIGN>  { jjtn000.jjtSetValue(OperatorValue.ASSIGN_MINUS); }
          |
        <MASSIGN>  { jjtn000.jjtSetValue(OperatorValue.ASTERISK_ASSIGN); }
          |
        <DASSIGN>  { jjtn000.jjtSetValue(OperatorValue.FSLASH_ASSIGN); }
          |
        <UASSIGN>  { jjtn000.jjtSetValue(OperatorValue.PERCENT_ASSIGN); }
          |
        <PASSIGN>  { jjtn000.jjtSetValue(OperatorValue.EXPON_ASSIGN); }
    )
    Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  2);
      }
    }
/*@egen*/
}

void RightExpression() : {}
{
    OrExpression()
}

void OrExpression() : {}
{
    AndExpression()
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<OR> AndExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.LOGICAL_OR); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
    )*
}

void AndExpression() : {}
{
    EqualExpression()
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<AND> EqualExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.LOGICAL_AND); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
    )*
}

void EqualExpression() : {}
{
    RelationalExpression()
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<EQ> RelationalExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.EQUALITY_EQ_OP); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn002 = new ASTOperator(JJTOPERATOR);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<NE> RelationalExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            { jjtn002.jjtSetValue(OperatorValue.EQUALITY_NE_OP); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/             
    )*
}

void RelationalExpression() : {}
{
    AdditiveExpression()
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<LT> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.RELATIONAL_LT_OP); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn002 = new ASTOperator(JJTOPERATOR);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<LE> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            { jjtn002.jjtSetValue(OperatorValue.RELATIONAL_LE_OP); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn003 = new ASTOperator(JJTOPERATOR);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
        (<GT> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn003,  2);
              jjtc003 = false;
            }
/*@egen*/
            { jjtn003.jjtSetValue(OperatorValue.RELATIONAL_GT_OP); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn004 = new ASTOperator(JJTOPERATOR);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*/
        (<GE> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn004,  2);
              jjtc004 = false;
            }
/*@egen*/
            { jjtn004.jjtSetValue(OperatorValue.RELATIONAL_GE_OP); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte004) {
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte004 instanceof RuntimeException) {
            throw (RuntimeException)jjte004;
          }
          if (jjte004 instanceof ParseException) {
            throw (ParseException)jjte004;
          }
          throw (Error)jjte004;
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004,  2);
          }
        }
/*@egen*/             
    )*
}

void AdditiveExpression() : {}
{
    MultiplicativeExpression()
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<PLUS> MultiplicativeExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.ADD); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn002 = new ASTOperator(JJTOPERATOR);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<MINUS> MultiplicativeExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            { jjtn002.jjtSetValue(OperatorValue.SUBTRACT); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/             
    )*
}

void MultiplicativeExpression() : {}
{
    UnaryExpression()
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<MUL> UnaryExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.MULTIPLY); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn002 = new ASTOperator(JJTOPERATOR);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<DIV> UnaryExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            { jjtn002.jjtSetValue(OperatorValue.DIVIDE); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn003 = new ASTOperator(JJTOPERATOR);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
        (<MOD> UnaryExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn003,  2);
              jjtc003 = false;
            }
/*@egen*/
            { jjtn003.jjtSetValue(OperatorValue.MODULUS); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  2);
          }
        }
/*@egen*/             
    )*
}

void UnaryExpression() : {}
{/*@bgen(jjtree) #Operator( 1) */
    {
      ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<PLUS> UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  1);
          jjtc001 = false;
        }
/*@egen*/
        { jjtn001.jjtSetValue(OperatorValue.UPLUS); }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
      }
    }
/*@egen*/             
      |/*@bgen(jjtree) #Operator( 1) */
    {
      ASTOperator jjtn002 = new ASTOperator(JJTOPERATOR);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    (<MINUS> UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002,  1);
          jjtc002 = false;
        }
/*@egen*/
        { jjtn002.jjtSetValue(OperatorValue.UMINUS); }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  1);
      }
    }
/*@egen*/             
      |/*@bgen(jjtree) #Operator( 1) */
    {
      ASTOperator jjtn003 = new ASTOperator(JJTOPERATOR);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/
    (<NOT> UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003,  1);
          jjtc003 = false;
        }
/*@egen*/
        { jjtn003.jjtSetValue(OperatorValue.LNOT); }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte003) {
      if (jjtc003) {
        jjtree.clearNodeScope(jjtn003);
        jjtc003 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte003 instanceof RuntimeException) {
        throw (RuntimeException)jjte003;
      }
      if (jjte003 instanceof ParseException) {
        throw (ParseException)jjte003;
      }
      throw (Error)jjte003;
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  1);
      }
    }
/*@egen*/             
      |/*@bgen(jjtree) #Operator( 1) */
    {
      ASTOperator jjtn004 = new ASTOperator(JJTOPERATOR);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
    }
    try {
/*@egen*/
    (<BNOT> UnaryExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn004,  1);
          jjtc004 = false;
        }
/*@egen*/
        { jjtn004.jjtSetValue(OperatorValue.BNOT); }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte004) {
      if (jjtc004) {
        jjtree.clearNodeScope(jjtn004);
        jjtc004 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte004 instanceof RuntimeException) {
        throw (RuntimeException)jjte004;
      }
      if (jjte004 instanceof ParseException) {
        throw (ParseException)jjte004;
      }
      throw (Error)jjte004;
    } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004,  1);
      }
    }
/*@egen*/             
      |
    ExponentiationExpression()
}

void ExponentiationExpression() : {}
{
    UnitExpression()
    (
        LOOKAHEAD(2)/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<EXPON> UnaryExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.EXPON); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
    )*
}

/* Unary Expression With Units:
   A unit expression acts as a post-fix operator with
   precedence higher than +, -, *, /, and %, but lower 
   than ** (exponentiation), unary minus, unary plus, 
   and element []. */
   
void UnitExpression() : {
    String unit = "";
}
{
    LOOKAHEAD(ValueExpression() <LBRC>)/*@bgen(jjtree) Unit */
    {
      ASTUnit jjtn001 = new ASTUnit(JJTUNIT);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (ValueExpression() <LBRC> unit = UnitsSpecification() <RBRC>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
        { jjtn001.jjtSetValue(new UnitValue(Unit.valueOf(unit))); }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/      
      | 
    ValueExpression()
}

void ValueExpression() : {}
{
    NonConstantExpandedExpression()    /* Includes "strings" and (<statement>) */
      |
    NumericOrBooleanOrNullConstant()
}

void NonConstantExpandedExpression() : {}
{
    MemberOrElementAccessableExpandedExpression()   /* Includes "strings" and (<statement>) */
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<DOT> MemberExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.DOT); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn002 = new ASTOperator(JJTOPERATOR);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<LSQ> Statement() <RSQ>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            { jjtn002.jjtSetValue(OperatorValue.INDEX); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/             
    )*
}

void NonConstantLimitedExpression() : {}   /* No "strings" nor (<statement>) */
{
    MemberOrElementAccessableLimitedExpression()   /* No "strings" nor (<statement>) */
    (/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn001 = new ASTOperator(JJTOPERATOR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<DOT> MemberExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            { jjtn001.jjtSetValue(OperatorValue.DOT); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
          |/*@bgen(jjtree) #Operator( 2) */
        {
          ASTOperator jjtn002 = new ASTOperator(JJTOPERATOR);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<LSQ> Statement() <RSQ>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            { jjtn002.jjtSetValue(OperatorValue.INDEX); }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/             
    )*
}

void MemberOrElementAccessableExpandedExpression() : {}
{
    LOOKAHEAD({getToken(1).kind == INDENTIFIER && getToken(2).kind == LRND})
    Function()
      |
    Variable()
      |
    StringConstant()
      |
    ListOrMapExpression()
      |
    <LRND> Statement() <RRND>
}

void MemberOrElementAccessableLimitedExpression() : {}
{
    LOOKAHEAD({getToken(1).kind == INDENTIFIER && getToken(2).kind == LRND})
    Function()
      |
    Variable()
}

void MemberExpression() : {}
{
    LOOKAHEAD({getToken(1).kind == INDENTIFIER && getToken(2).kind == LRND})
    Function()
      |
    Variable()
}

void ListOrMapExpression()            : {/*@bgen(jjtree) ListOrMap */
    ASTListOrMap jjtn000 = new ASTListOrMap(JJTLISTORMAP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    jjtn000.jjtSetValue(new ListOrMapValue());
}
{/*@bgen(jjtree) ListOrMap */
    try {
/*@egen*/
    <LSQ>
      (
          (
              (LOOKAHEAD(Statement() <COLON>) KeyValuePairExpression() | Statement())
              (
                  <COMMA>
                  (LOOKAHEAD(Statement() <COLON>) KeyValuePairExpression() | Statement())
              )*
          )
            |
          <COLON> { jjtn000.setEmptyMap(true); }
      )?
    <RSQ>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void KeyValuePairExpression()               : {/*@bgen(jjtree) KeyValuePair */
    ASTKeyValuePair jjtn000 = new ASTKeyValuePair(JJTKEYVALUEPAIR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    jjtn000.jjtSetValue(new KeyValuePairValue());
}
{/*@bgen(jjtree) KeyValuePair */
    try {
/*@egen*/
    Statement() <COLON> Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StringConstant()           : {/*@bgen(jjtree) Constant */
                                    ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Constant */
    try {
/*@egen*/
    t = <STRING_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        String temp = t.image.substring(1, t.image.length() - 1);
        temp = replaceEscape(temp);
        jjtn000.jjtSetValue(new ConstantValue(temp));
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumericOrBooleanOrNullConstant()           : {/*@bgen(jjtree) Constant */
                                                    ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
                                                    boolean jjtc000 = true;
                                                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Object value; }
{/*@bgen(jjtree) Constant */
    try {
/*@egen*/
    value = RealConstant()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/     { jjtn000.jjtSetValue(new ConstantValue(value)); }
      |
    value = BooleanConstant()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/  { jjtn000.jjtSetValue(new ConstantValue(value)); }
      |
    value = NullConstant()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/     { jjtn000.jjtSetValue(new ConstantValue(value)); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Object RealConstant() : { Token t; }
{
    t = <INTEGER_LITERAL>         { return Long.parseLong(t.image); }
      |
    t = <FLOATING_POINT_LITERAL>  { return Double.parseDouble(t.image); }
}

Boolean BooleanConstant() : {}
{
    <TRUE_LITERAL>   { return true; }    
      | 
    <FALSE_LITERAL>  { return false; }
}

Null NullConstant() : {}
{
    <NULL_LITERAL>   { return Null.NULL; }    
}

void Function() : { String id = ""; }
{/*@bgen(jjtree) Function */
    {
      ASTFunction jjtn001 = new ASTFunction(JJTFUNCTION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (id = Identifier()
        { jjtn001.jjtSetValue(new FunctionValue(id)); }
        <LRND> ArgumentList() <RRND>
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/          
}

void ArgumentList() : {}
{
    [Statement() (<COMMA> Statement())*]
}

void Variable()           : {/*@bgen(jjtree) Variable */
                              ASTVariable jjtn000 = new ASTVariable(JJTVARIABLE);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ String id = ""; }
{/*@bgen(jjtree) Variable */
    try {
/*@egen*/
    id = Identifier()/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/  { jjtn000.jjtSetValue(new VariableValue(id)); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LValue() : {
   String unit = "";
}
{
    LOOKAHEAD(LValueWithoutUnits() <LBRC>)/*@bgen(jjtree) Unit */
    {
      ASTUnit jjtn001 = new ASTUnit(JJTUNIT);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (LValueWithoutUnits() <LBRC> unit = UnitsSpecification() <RBRC>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
        { jjtn001.jjtSetValue(new UnitValue(Unit.valueOf(unit))); }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/      
      | 
    LValueWithoutUnits()
}

void LValueWithoutUnits() : {}
{
    NonConstantLimitedExpression()
}

String Identifier() : { Token t; }
{
    t = <INDENTIFIER> { return t.image; }
}

String UnitsSpecification() : { Token t; }
{
    t = <UNITS> { return t.image; }
}
